<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>bayesad_2 – Master Thesis Literature Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Master Thesis Literature Review</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../../posts/index.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block"></header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#연구-기획서-초안" id="toc-연구-기획서-초안" class="nav-link active" data-scroll-target="#연구-기획서-초안">연구 기획서 (초안)</a>
  <ul class="collapse">
  <li><a href="#연구-주제-가제" id="toc-연구-주제-가제" class="nav-link" data-scroll-target="#연구-주제-가제">1. 연구 주제 (가제)</a></li>
  <li><a href="#연구-배경-및-필요성" id="toc-연구-배경-및-필요성" class="nav-link" data-scroll-target="#연구-배경-및-필요성">2. 연구 배경 및 필요성</a></li>
  <li><a href="#연구-목표-및-연구-질문" id="toc-연구-목표-및-연구-질문" class="nav-link" data-scroll-target="#연구-목표-및-연구-질문">3. 연구 목표 및 연구 질문</a>
  <ul class="collapse">
  <li><a href="#연구-목표" id="toc-연구-목표" class="nav-link" data-scroll-target="#연구-목표">3.1 연구 목표</a></li>
  <li><a href="#연구-질문-research-questions" id="toc-연구-질문-research-questions" class="nav-link" data-scroll-target="#연구-질문-research-questions">3.2 연구 질문 (Research Questions)</a></li>
  </ul></li>
  <li><a href="#선행-연구-및-키워드-세트" id="toc-선행-연구-및-키워드-세트" class="nav-link" data-scroll-target="#선행-연구-및-키워드-세트">4. 선행 연구 및 키워드 세트</a>
  <ul class="collapse">
  <li><a href="#키워드-세트" id="toc-키워드-세트" class="nav-link" data-scroll-target="#키워드-세트">4.1 키워드 세트</a></li>
  <li><a href="#선행연구-조사-계획" id="toc-선행연구-조사-계획" class="nav-link" data-scroll-target="#선행연구-조사-계획">4.2 선행연구 조사 계획</a></li>
  </ul></li>
  <li><a href="#연구-내용-및-방법" id="toc-연구-내용-및-방법" class="nav-link" data-scroll-target="#연구-내용-및-방법">5. 연구 내용 및 방법</a>
  <ul class="collapse">
  <li><a href="#base-model-variational-autoencoder-기반-다변량-이상치-uq" id="toc-base-model-variational-autoencoder-기반-다변량-이상치-uq" class="nav-link" data-scroll-target="#base-model-variational-autoencoder-기반-다변량-이상치-uq">5.1 Base Model: Variational Autoencoder 기반 다변량 이상치 + UQ</a></li>
  <li><a href="#extended-model-mixture-of-vaesmovae-기반-다중-모드-모델" id="toc-extended-model-mixture-of-vaesmovae-기반-다중-모드-모델" class="nav-link" data-scroll-target="#extended-model-mixture-of-vaesmovae-기반-다중-모드-모델">5.2 Extended Model: Mixture-of-VAEs(MoVAE) 기반 다중 모드 모델</a></li>
  <li><a href="#위험-민감risk-aware-의사결정-규칙" id="toc-위험-민감risk-aware-의사결정-규칙" class="nav-link" data-scroll-target="#위험-민감risk-aware-의사결정-규칙">5.3 위험 민감(risk-aware) 의사결정 규칙</a></li>
  <li><a href="#구현-계획" id="toc-구현-계획" class="nav-link" data-scroll-target="#구현-계획">5.4 구현 계획</a></li>
  </ul></li>
  <li><a href="#실험-계획" id="toc-실험-계획" class="nav-link" data-scroll-target="#실험-계획">6. 실험 계획</a>
  <ul class="collapse">
  <li><a href="#데이터셋-예시-방향" id="toc-데이터셋-예시-방향" class="nav-link" data-scroll-target="#데이터셋-예시-방향">6.1 데이터셋 (예시 방향)</a></li>
  <li><a href="#비교-방법-및-지표" id="toc-비교-방법-및-지표" class="nav-link" data-scroll-target="#비교-방법-및-지표">6.2 비교 방법 및 지표</a></li>
  </ul></li>
  <li><a href="#연구-일정-12개월-기준-예시" id="toc-연구-일정-12개월-기준-예시" class="nav-link" data-scroll-target="#연구-일정-12개월-기준-예시">7. 연구 일정 (12개월 기준 예시)</a></li>
  <li><a href="#기대-효과-및-기여" id="toc-기대-효과-및-기여" class="nav-link" data-scroll-target="#기대-효과-및-기여">8. 기대 효과 및 기여</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="연구-기획서-초안" class="level1">
<h1>연구 기획서 (초안)</h1>
<section id="연구-주제-가제" class="level2">
<h2 class="anchored" data-anchor-id="연구-주제-가제">1. 연구 주제 (가제)</h2>
<p><strong>다변량 딥러닝 기반 이상치 탐지에서의 불확실성 추정과<br>
Mixture-of-VAEs를 활용한 위험 민감 의사결정 프레임워크</strong></p>
<p>(영문 예시)<br>
<strong>Risk-Aware Decision Framework with Uncertainty-Aware Deep Multivariate Anomaly Detection using Variational and Mixture-of-VAEs</strong></p>
<hr>
</section>
<section id="연구-배경-및-필요성" class="level2">
<h2 class="anchored" data-anchor-id="연구-배경-및-필요성">2. 연구 배경 및 필요성</h2>
<p>제조 공정, 네트워크 트래픽, 금융 거래, 의료 모니터링 등 다양한 응용 분야에서 다변량(multivariate) 시계열·표형 데이터에 대한 <strong>이상치 탐지(anomaly / outlier detection) </strong>는 안전성, 비용 절감, 서비스 안정성 측면에서 매우 중요한 과제이다.</p>
<p>그러나 기존 딥러닝 기반 이상치 탐지 기법들(예: Autoencoder, LSTM-AE, CNN 기반 모델 등)은 다음과 같은 한계를 가진다.</p>
<ol type="1">
<li><strong>이상치 점수만 제공</strong>
<ul>
<li>단일 스칼라 점수 <span class="math inline">\(A(x)\)</span>만 제공하는 경우가 많아,<br>
“얼마나 이상한가?”는 알 수 있어도<br>
“이 판단을 얼마나 믿을 수 있는가?”(불확실성)는 알기 어렵다.</li>
</ul></li>
<li><strong>불확실성(uncertainty) 정보 부재</strong>
<ul>
<li>모델이 자신 없는 영역에서 내린 이상치 판단을<br>
동일한 신뢰도로 사용하게 되며,<br>
이는 실제 운영 환경에서 위험한 결정으로 이어질 수 있다.</li>
</ul></li>
<li><strong>비용 구조가 반영되지 않은 결정</strong>
<ul>
<li>실제 시스템에서는
<ul>
<li>정상인데 이상치로 판단할 때의 비용(공장 정지, 서비스 중단 등)<br>
</li>
<li>이상치인데 정상으로 넘기는 비용(고장, 사고, 손실 등)<br>
</li>
<li>사람/전문가에게 “검토를 요청할 때” 드는 비용<br>
이 서로 다름에도 불구하고,<br>
단일 threshold 기반 이진 결정으로만 처리되는 경우가 많다.</li>
</ul></li>
</ul></li>
</ol>
<p>이에 본 연구는, <strong>딥러닝 기반 베이지안 VAE와 Mixture-of-VAEs</strong>를 활용하여</p>
<ul>
<li>다변량 데이터에서 <strong>이상치 점수와 불확실성을 동시에 추정</strong>하고,</li>
<li>이를 바탕으로 <strong>STOP / CHECK / IGNORE</strong> 형태의<br>
<strong>위험 민감(risk-aware) 의사결정 규칙</strong>을 설계하고자 한다.</li>
</ul>
<hr>
</section>
<section id="연구-목표-및-연구-질문" class="level2">
<h2 class="anchored" data-anchor-id="연구-목표-및-연구-질문">3. 연구 목표 및 연구 질문</h2>
<section id="연구-목표" class="level3">
<h3 class="anchored" data-anchor-id="연구-목표">3.1 연구 목표</h3>
<ol type="1">
<li><p><strong>Base Model</strong>:<br>
Variational Autoencoder(VAE)를 기반으로 한 <strong>다변량 딥러닝 이상치 탐지 모델</strong>을 설계하여,<br>
전역(global) 및 변수별(feature-wise) 이상치 점수와 불확실성을 동시에 추정한다.</p></li>
<li><p><strong>Extended Model</strong>:<br>
데이터가 여러 정상 모드(운영 상태)를 가진다고 가정하고,<br>
<strong>Mixture-of-VAEs (MoVAE)</strong> 구조를 설계하여<br>
모드별 이상치·불확실성과 <strong>모드 자체에 대한 불확실성(mode uncertainty)</strong> 를 함께 추정한다.</p></li>
<li><p><strong>Risk-aware Decision</strong>:<br>
이상치 점수와 불확실성 정보를 활용해<br>
비용 구조를 반영한 <strong>3-way 의사결정(STOP / CHECK / IGNORE)</strong> 규칙을 정식화하고,<br>
기존 threshold 기반 기법보다 더 낮은 위험도(risk)를 달성하는지 평가한다.</p></li>
<li><p><strong>범용성 검증</strong>:<br>
공정/센서 시계열, 네트워크/트래픽, 공개 multivariate anomaly dataset 등<br>
서로 다른 도메인에서 제안 프레임워크의 <strong>일관된 효과</strong>를 검증한다.</p></li>
</ol>
</section>
<section id="연구-질문-research-questions" class="level3">
<h3 class="anchored" data-anchor-id="연구-질문-research-questions">3.2 연구 질문 (Research Questions)</h3>
<ul>
<li><p><strong>RQ1.</strong> Variational Autoencoder 기반 다변량 딥러닝 모델을 통해<br>
전역 및 변수별 이상치 점수 <span class="math inline">\(A(x)\)</span>와 불확실성 <span class="math inline">\(U(x)\)</span>를 동시에 추정할 수 있는가?</p></li>
<li><p><strong>RQ2.</strong> 데이터가 여러 정상 모드를 가질 때, 단일 VAE보다<br>
Mixture-of-VAEs가 이상치 탐지 및 불확실성 추정 측면에서<br>
더 나은 표현력과 의사결정 성능을 제공하는가?</p></li>
<li><p><strong>RQ3.</strong> 추정된 <span class="math inline">\((A(x), U(x))\)</span> (및 모드 불확실성)를 이용하여<br>
STOP / CHECK / IGNORE 형태의 위험 민감 의사결정 규칙을 설계할 때,<br>
기존 단일 threshold 기반 이진 의사결정보다<br>
실제 비용(risk)을 유의하게 감소시킬 수 있는가?</p></li>
</ul>
<hr>
</section>
</section>
<section id="선행-연구-및-키워드-세트" class="level2">
<h2 class="anchored" data-anchor-id="선행-연구-및-키워드-세트">4. 선행 연구 및 키워드 세트</h2>
<section id="키워드-세트" class="level3">
<h3 class="anchored" data-anchor-id="키워드-세트">4.1 키워드 세트</h3>
<ul>
<li><strong>이상치 탐지 / 다변량</strong>
<ul>
<li>multivariate anomaly detection<br>
</li>
<li>multivariate time series anomaly detection<br>
</li>
<li>deep anomaly detection, deep autoencoder, VAE anomaly detection<br>
</li>
<li>reconstruction-based anomaly detection</li>
</ul></li>
<li><strong>딥러닝 &amp; 베이지안 / 불확실성</strong>
<ul>
<li>deep learning, representation learning (PyTorch / fastai)<br>
</li>
<li>Bayesian deep learning, variational inference<br>
</li>
<li>Monte Carlo Dropout, deep ensemble<br>
</li>
<li>uncertainty quantification, aleatoric / epistemic uncertainty<br>
</li>
<li>Variational Autoencoder, Bayesian VAE, probabilistic autoencoder<br>
</li>
<li>mixture of VAEs, mixture density networks, mixture-of-experts</li>
</ul></li>
<li><strong>의사결정 / 위험</strong>
<ul>
<li>selective prediction, abstention, reject option<br>
</li>
<li>risk-aware decision making, cost-sensitive learning<br>
</li>
<li>risk–coverage trade-off, calibration</li>
</ul></li>
</ul>
</section>
<section id="선행연구-조사-계획" class="level3">
<h3 class="anchored" data-anchor-id="선행연구-조사-계획">4.2 선행연구 조사 계획</h3>
<ul>
<li><strong>1–2개월차</strong>에 집중적으로 논문 수집 및 정리</li>
<li>각 논문에 대해 다음 항목으로 구조화:
<ul>
<li>데이터 타입 (시계열, 이미지, 센서, 트래픽 등)<br>
</li>
<li>딥러닝 사용 여부, VAE/flow/AE 등 모델 유형<br>
</li>
<li>이상치 점수 정의 방식 (reconstruction, likelihood, distance 등)<br>
</li>
<li>불확실성 추정 여부 및 방법<br>
</li>
<li>risk-aware / selective decision 관점 고려 여부<br>
</li>
<li>본 연구와의 차별점 / 한 줄 평가</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="연구-내용-및-방법" class="level2">
<h2 class="anchored" data-anchor-id="연구-내용-및-방법">5. 연구 내용 및 방법</h2>
<p>본 연구는 <strong>Base Model(VAE)</strong>와 <strong>Extended Model(Mixture-of-VAEs)</strong>으로 구성되며,<br>
두 모델에서 공통적으로 <strong>이상치 점수 + 불확실성 추정 + risk-aware decision layer</strong>를 설계한다.</p>
<section id="base-model-variational-autoencoder-기반-다변량-이상치-uq" class="level3">
<h3 class="anchored" data-anchor-id="base-model-variational-autoencoder-기반-다변량-이상치-uq">5.1 Base Model: Variational Autoencoder 기반 다변량 이상치 + UQ</h3>
<section id="확률-모형" class="level4">
<h4 class="anchored" data-anchor-id="확률-모형">5.1.1 확률 모형</h4>
<p>다변량 입력 <span class="math inline">\(x \in \mathbb{R}^d\)</span>에 대해, VAE 구조는 다음과 같이 정의한다.</p>
<ul>
<li>Prior:</li>
</ul>
<p><span class="math display">\[
z \sim p(z) = \mathcal{N}(0, I)
\]</span></p>
<ul>
<li>Decoder:</li>
</ul>
<p><span class="math display">\[
p_\theta(x \mid z) = \mathcal{N}\big(\mu_\theta(z), \text{diag}(\sigma^2_\theta(z))\big)
\]</span></p>
<ul>
<li>Encoder (approximate posterior):</li>
</ul>
<p><span class="math display">\[
q_\phi(z \mid x) = \mathcal{N}\big(\mu_\phi(x), \text{diag}(\sigma^2_\phi(x))\big)
\]</span></p>
<p>학습은 ELBO 최적화를 통해 수행한다.</p>
<ul>
<li>ELBO:</li>
</ul>
<p><span class="math display">\[
\mathcal{L}_{\text{ELBO}}(x;\theta,\phi) = \mathbb{E}_{q_\phi(z\mid x)}[\log p_\theta(x \mid z)] - \mathrm{KL}\big(q_\phi(z\mid x)\,\|\,p(z)\big)
\]</span></p>
<p>PyTorch/fastai로는 encoder/decoder를 MLP, 1D-CNN, LSTM 등으로 구현하고,<br>
출력층에서 mean 및 log-variance를 예측하도록 구성한다.</p>
</section>
<section id="이상치-점수-및-불확실성-정의" class="level4">
<h4 class="anchored" data-anchor-id="이상치-점수-및-불확실성-정의">5.1.2 이상치 점수 및 불확실성 정의</h4>
<p>관측 <span class="math inline">\(x\)</span>에 대해, 다음과 같이 Monte Carlo 샘플링을 수행한다.</p>
<ol type="1">
<li><span class="math inline">\(z^{(t)} \sim q_\phi(z \mid x), \quad t = 1,\dots,T\)</span></li>
<li><span class="math inline">\(\hat x^{(t)} \sim p_\theta(x \mid z^{(t)})\)</span></li>
</ol>
<p>각 변수 <span class="math inline">\(j = 1,\dots,d\)</span>에 대해:</p>
<ul>
<li><strong>변수별 이상치 점수 (재구성 오차)</strong></li>
</ul>
<p><span class="math display">\[
r_j(x) = \frac{1}{T} \sum_{t=1}^T \big(x_j - \hat x^{(t)}_j\big)^2
\]</span></p>
<ul>
<li><strong>변수별 불확실성 (예측 분산)</strong><br>
평균 재구성을</li>
</ul>
<p><span class="math display">\[
\bar x_j = \frac{1}{T} \sum_{t=1}^T \hat x^{(t)}_j
\]</span></p>
<p>로 정의할 때,</p>
<p><span class="math display">\[
u_j(x) = \frac{1}{T-1} \sum_{t=1}^T \big(\hat x^{(t)}_j - \bar x_j\big)^2
\]</span></p>
<p>전역(global) 이상치 점수와 불확실성은 가중합으로 정의한다.</p>
<ul>
<li>전역 이상치 점수:</li>
</ul>
<p><span class="math display">\[
A_{\text{VAE}}(x) = \sum_{j=1}^d w_j r_j(x)
\]</span></p>
<ul>
<li>전역 불확실성:</li>
</ul>
<p><span class="math display">\[
U_{\text{VAE}}(x) = \sum_{j=1}^d w_j u_j(x)
\]</span></p>
<p>여기서 <span class="math inline">\(w_j\)</span>는 각 변수의 중요도를 반영하는 가중치(동일 가중치 또는 도메인 지식 기반)를 의미한다.</p>
<p>필요 시, encoder/decoder 네트워크에 <strong>Dropout</strong>을 적용하여<br>
epistemic uncertainty를 추가로 반영할 수 있다.</p>
<hr>
</section>
</section>
<section id="extended-model-mixture-of-vaesmovae-기반-다중-모드-모델" class="level3">
<h3 class="anchored" data-anchor-id="extended-model-mixture-of-vaesmovae-기반-다중-모드-모델">5.2 Extended Model: Mixture-of-VAEs(MoVAE) 기반 다중 모드 모델</h3>
<section id="모드운영-상태-가정-및-구조" class="level4">
<h4 class="anchored" data-anchor-id="모드운영-상태-가정-및-구조">5.2.1 모드(운영 상태) 가정 및 구조</h4>
<p>다변량 데이터가 여러 정상 모드(운영 상태)를 가진다고 가정한다.<br>
이를 위해 <span class="math inline">\(K\)</span>개의 VAE expert와 gating network로 구성된 Mixture-of-VAEs 구조를 정의한다.</p>
<ul>
<li>Gating network:</li>
</ul>
<p><span class="math display">\[
\pi_k(x) = p_\psi(k \mid x), \quad k = 1,\dots,K
\]</span></p>
<p>여기서 <span class="math inline">\(\pi_k(x)\)</span>는 입력 <span class="math inline">\(x\)</span>가 모드 <span class="math inline">\(k\)</span>에 속할 확률을 나타내며,<br>
<span class="math inline">\(\sum_{k=1}^K \pi_k(x) = 1\)</span>을 만족한다.</p>
<ul>
<li>각 expert VAE:</li>
</ul>
<p><span class="math display">\[
z_k \sim p(z_k) = \mathcal{N}(0, I)
\]</span></p>
<p><span class="math display">\[
p_{\theta_k}(x \mid z_k) = \mathcal{N}\big(\mu_{\theta_k}(z_k), \text{diag}(\sigma^2_{\theta_k}(z_k))\big)
\]</span></p>
<p><span class="math display">\[
q_{\phi_k}(z_k \mid x) = \mathcal{N}\big(\mu_{\phi_k}(x), \text{diag}(\sigma^2_{\phi_k}(x))\big)
\]</span></p>
<ul>
<li>전체 likelihood:</li>
</ul>
<p><span class="math display">\[
p(x) = \sum_{k=1}^K \pi_k(x)\, p_{\theta_k}(x)
\]</span></p>
<p>학습은 mixture 형태의 ELBO 또는 EM-유사 전략,<br>
혹은 end-to-end joint training으로 수행할 수 있으며,<br>
실험 단계에서 구현 난이도와 성능을 고려하여 선택한다.</p>
</section>
<section id="mixture-기반-이상치-점수" class="level4">
<h4 class="anchored" data-anchor-id="mixture-기반-이상치-점수">5.2.2 Mixture 기반 이상치 점수</h4>
<p>각 expert에 대해, VAE와 동일하게 재구성 기반 점수 <span class="math inline">\(A_k(x)\)</span>를 정의한다.</p>
<ul>
<li>expert <span class="math inline">\(k\)</span>의 이상치 점수(예시):</li>
</ul>
<p><span class="math display">\[
A_k(x) = \sum_{j=1}^d w_j r_{j,k}(x)
\]</span></p>
<p>Mixture 전체의 이상치 점수는 다음과 같이 정의할 수 있다.</p>
<ol type="1">
<li><strong>likelihood 기반:</strong></li>
</ol>
<p><span class="math display">\[
A_{\text{MoVAE}}(x) = -\log \left( \sum_{k=1}^K \pi_k(x)\, p_{\theta_k}(x) \right)
\]</span></p>
<ol start="2" type="1">
<li><strong>reconstruction 기반 가중합:</strong></li>
</ol>
<p><span class="math display">\[
A_{\text{MoVAE}}(x) = \sum_{k=1}^K \pi_k(x)\, A_k(x)
\]</span></p>
<p>두 정의는 실험에서 비교 가능하며,<br>
도메인 특성에 따라 더 좋은 score 정의를 선택할 수 있다.</p>
</section>
<section id="불확실성-모드-내부-모드-간-계층-구조" class="level4">
<h4 class="anchored" data-anchor-id="불확실성-모드-내부-모드-간-계층-구조">5.2.3 불확실성: 모드 내부 + 모드 간 계층 구조</h4>
<p>Mixture-of-VAEs에서는 불확실성이 <strong>두 층</strong>으로 나뉜다.</p>
<ol type="1">
<li><strong>expert 내부 불확실성 (in-expert uncertainty)</strong>
<ul>
<li>각 expert <span class="math inline">\(k\)</span>의 VAE에서 variance, MC 샘플 분산 등을 이용해<br>
<span class="math inline">\(U_k(x)\)</span>를 정의 (Base VAE와 동일 방식).</li>
</ul></li>
<li><strong>모드 불확실성 (between-expert / mode uncertainty)</strong>
<ul>
<li>gating 확률 벡터 <span class="math inline">\(\pi(x) = (\pi_1(x),\dots,\pi_K(x))\)</span>의 엔트로피:</li>
</ul></li>
</ol>
<p><span class="math display">\[
H_\pi(x) = -\sum_{k=1}^K \pi_k(x)\log \pi_k(x)
\]</span></p>
<ul>
<li><span class="math inline">\(\pi_k(x)\)</span>가 한 모드에 집중되면 <span class="math inline">\(H_\pi(x)\)</span>가 작고,<br>
여러 모드에 고르게 분산되면 <span class="math inline">\(H_\pi(x)\)</span>가 커진다.<br>
→ “이 샘플이 어느 모드에 속하는지 모델이 헷갈리는 정도”로 해석 가능.</li>
</ul>
<ol start="3" type="1">
<li><strong>종합 불확실성 정의 예시</strong></li>
</ol>
<p><span class="math display">\[
U_{\text{MoVAE}}(x) = \alpha \sum_{k=1}^K \pi_k(x)\, U_k(x) + \beta H_\pi(x)
\]</span></p>
<p>여기서 <span class="math inline">\(\alpha, \beta\)</span>는 모드 내부 불확실성과 모드 불확실성의 상대적 중요도를 조절하는 하이퍼파라미터이다.</p>
<hr>
</section>
</section>
<section id="위험-민감risk-aware-의사결정-규칙" class="level3">
<h3 class="anchored" data-anchor-id="위험-민감risk-aware-의사결정-규칙">5.3 위험 민감(risk-aware) 의사결정 규칙</h3>
<section id="의사결정-세트-및-비용-함수" class="level4">
<h4 class="anchored" data-anchor-id="의사결정-세트-및-비용-함수">5.3.1 의사결정 세트 및 비용 함수</h4>
<p>각 샘플 <span class="math inline">\(x\)</span>에 대하여, 세 가지 행동 중 하나를 선택한다고 가정한다.</p>
<ul>
<li><span class="math inline">\(\delta(x) \in \{\text{IGNORE}, \text{CHECK}, \text{STOP}\}\)</span></li>
</ul>
<p>실제 상태 <span class="math inline">\(y \in \{\text{normal}, \text{anomaly}\}\)</span>에 대해,<br>
각 행동에 대한 비용을 <span class="math inline">\(C(\delta(x), y)\)</span>로 정의한다.</p>
<p>예시:</p>
<ul>
<li>정상인데 STOP → 불필요한 정지, false positive 비용<br>
</li>
<li>이상치인데 IGNORE → 사고/고장, false negative 비용 (가장 큼)<br>
</li>
<li>CHECK → 사람/추가 검사 비용 (중간 수준)</li>
</ul>
<p>전체 기대 위험도(risk)는 다음과 같이 정의할 수 있다.</p>
<p><span class="math display">\[
R(\delta) = \mathbb{E}_{(x,y)}\big[\,C(\delta(x), y)\,\big]
\]</span></p>
<p>실제 구현에서는 validation set 상에서의 <strong>경험적 위험</strong> <span class="math inline">\(\hat R(\delta)\)</span>를 최소화하는 규칙을 찾는다.</p>
</section>
<section id="ax-ux-기반-3-way-decision-rule" class="level4">
<h4 class="anchored" data-anchor-id="ax-ux-기반-3-way-decision-rule">5.3.2 <span class="math inline">\((A(x), U(x))\)</span> 기반 3-way decision rule</h4>
<p>Base VAE 및 MoVAE 모두, 이상치 점수 <span class="math inline">\(A(x)\)</span>와 불확실성 <span class="math inline">\(U(x)\)</span>를 기반으로 다음과 같은 규칙을 정의할 수 있다.</p>
<p>예시 규칙:</p>
<p><span class="math display">\[
\delta(x) =
\begin{cases}
\text{STOP} &amp; \text{if } A(x) \ge \tau_A \text{ and } U(x) \le \tau_U \\
\text{CHECK} &amp; \text{if } A(x) \ge \tau_A \text{ and } U(x) &gt; \tau_U \\
\text{IGNORE} &amp; \text{if } A(x) &lt; \tau_A
\end{cases}
\]</span></p>
<p>여기서 <span class="math inline">\((\tau_A, \tau_U)\)</span>는 validation set에서<br>
경험적 위험 <span class="math inline">\(\hat R(\tau_A,\tau_U)\)</span>를 최소화하도록 탐색한다.</p>
<p>Mixture-of-VAEs의 경우,<br>
<span class="math inline">\(U(x)\)</span>를 <span class="math inline">\(U_{\text{MoVAE}}(x)\)</span>로 두거나,<br>
모드 엔트로피 <span class="math inline">\(H_\pi(x)\)</span>를 추가 입력으로 사용하는 변형도 고려할 수 있다.</p>
<hr>
</section>
</section>
<section id="구현-계획" class="level3">
<h3 class="anchored" data-anchor-id="구현-계획">5.4 구현 계획</h3>
<ul>
<li><strong>프레임워크</strong>: PyTorch (필수), 필요 시 fastai로 학습/실험 루프 관리</li>
<li><strong>구성 요소</strong>
<ul>
<li><code>models/</code> : VAE, Mixture-of-VAEs, gating network 모듈<br>
</li>
<li><code>datasets/</code> : 시계열/탭형 multivariate anomaly dataset 로더<br>
</li>
<li><code>training/</code> : 학습 루프, ELBO 계산, threshold search, risk 계산<br>
</li>
<li><code>analysis/</code> : ROC, PR, risk–coverage, 의사결정 시뮬레이션, 시각화</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="실험-계획" class="level2">
<h2 class="anchored" data-anchor-id="실험-계획">6. 실험 계획</h2>
<section id="데이터셋-예시-방향" class="level3">
<h3 class="anchored" data-anchor-id="데이터셋-예시-방향">6.1 데이터셋 (예시 방향)</h3>
<ul>
<li><strong>Synthetic multivariate 데이터</strong>
<ul>
<li>다변량 Gaussian, mixture, non-linear manifold 데이터 생성<br>
</li>
<li>단일 모드 vs 다중 모드 환경에서 VAE와 MoVAE 비교</li>
</ul></li>
<li><strong>공개 multivariate anomaly dataset</strong>
<ul>
<li>예: 서버/센서/시계열 관련 공개 데이터셋 (SMD, MSL, SWaT 등)<br>
</li>
<li>도메인에 따라 tabular/multivariate time series 데이터 추가 검토</li>
</ul></li>
</ul>
</section>
<section id="비교-방법-및-지표" class="level3">
<h3 class="anchored" data-anchor-id="비교-방법-및-지표">6.2 비교 방법 및 지표</h3>
<ul>
<li><strong>Baseline 모델</strong>
<ul>
<li>단순 Autoencoder 기반 이상치 탐지<br>
</li>
<li>VAE (불확실성 고려하지 않는 score-only 버전)<br>
</li>
<li>필요시 다른 딥러닝 기반 anomaly detection 방법</li>
</ul></li>
<li><strong>성능 지표</strong>
<ul>
<li>이상치 탐지:
<ul>
<li>AUROC, AUPR, F1-score, FPR@95TPR 등</li>
</ul></li>
<li>의사결정 / risk 관점:
<ul>
<li>risk–coverage curve<br>
</li>
<li>false alarm 수, missed anomaly 수<br>
</li>
<li>CHECK(사람 검토) 비율 대비 risk 감소 정도</li>
</ul></li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="연구-일정-12개월-기준-예시" class="level2">
<h2 class="anchored" data-anchor-id="연구-일정-12개월-기준-예시">7. 연구 일정 (12개월 기준 예시)</h2>
<ol type="1">
<li><strong>1–2개월차: 문헌 조사 및 문제 정의</strong>
<ul>
<li>키워드 기반 선행 연구 수집 및 정리<br>
</li>
<li>관련 연구 요약 및 연구 질문(RQ) 확정</li>
</ul></li>
<li><strong>3–4개월차: 수식 정식화 및 모델 설계</strong>
<ul>
<li>VAE / Mixture-of-VAEs 수식 정리 및 손실 함수 정의<br>
</li>
<li>이상치 점수, 불확실성, decision rule 공식화<br>
</li>
<li>간단한 이론적 성질(정의, lemma, risk–coverage 개념) 초안 작성</li>
</ul></li>
<li><strong>5–7개월차: PyTorch 구현 및 초기 실험</strong>
<ul>
<li>Base VAE 및 MoVAE 구현<br>
</li>
<li>synthetic 데이터 및 1개 공개 데이터셋에서 1차 검증<br>
</li>
<li>코드 구조 안정화 및 hyperparameter 기본 설정</li>
</ul></li>
<li><strong>8–9개월차: 본 실험 및 분석</strong>
<ul>
<li>추가 데이터셋에 대한 본격 실험<br>
</li>
<li>Single VAE vs Mixture-of-VAEs 비교<br>
</li>
<li>risk-aware decision 관점에서의 성능 분석 및 ablation study</li>
</ul></li>
<li><strong>10–11개월차: 논문 집필</strong>
<ul>
<li>방법론(3–4장), 실험(5장)부터 집필<br>
</li>
<li>서론·관련연구(1–2장), 결론(6장) 작성 및 통합<br>
</li>
<li>지도교수 피드백 반영 및 수정</li>
</ul></li>
<li><strong>12개월차: 최종 정리 및 제출</strong>
<ul>
<li>논문 형식, 참고문헌, 그림/표 정리<br>
</li>
<li>발표 자료 준비 및 최종 점검</li>
</ul></li>
</ol>
<hr>
</section>
<section id="기대-효과-및-기여" class="level2">
<h2 class="anchored" data-anchor-id="기대-효과-및-기여">8. 기대 효과 및 기여</h2>
<ol type="1">
<li><strong>모델링 기여</strong>
<ul>
<li>다변량 데이터를 위한 <strong>딥러닝 기반 Bayesian VAE + Mixture-of-VAEs</strong> 구조를 설계하여,<br>
전역 및 변수별 이상치 점수와 <strong>계층적 불확실성(internal + mode uncertainty)</strong>을 동시에 제공한다.</li>
</ul></li>
<li><strong>의사결정 기여</strong>
<ul>
<li>이상치 점수와 불확실성을 활용한 <strong>risk-aware 3-way 의사결정(STOP / CHECK / IGNORE)</strong> 규칙을 제안하고,<br>
비용 구조를 반영한 위험도 관점에서 기존 방법보다 더 나은 성능을 보임을 보인다.</li>
</ul></li>
<li><strong>범용성 기여</strong>
<ul>
<li>공정/센서, 네트워크/트래픽, 일반 multivariate dataset 등<br>
서로 다른 도메인에 동일 프레임워크를 적용함으로써,<br>
<strong>범용적인 “이상치 + 불확실성 + 의사결정” 프레임워크</strong>로서의 가능성을 제시한다.</li>
</ul></li>
<li><strong>실무 적용 가능성</strong>
<ul>
<li>실제 시스템에서
<ul>
<li>언제 자동으로 STOP할지,<br>
</li>
<li>언제 사람에게 CHECK를 요청할지,<br>
</li>
<li>언제 IGNORE해도 되는지<br>
를 정량적으로 판단하는 기준을 제공하여,<br>
신뢰 가능한 이상치 탐지 기반 의사결정 시스템 설계에 기여할 수 있다.</li>
</ul></li>
</ul></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>