<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김한울">
<meta name="dcterms.date" content="2025-11-15">
<meta name="description" content="메타 러닝 관련 논문 요약 및 주요 내용">

<title>Successive model-agnostic meta-learning for few-shot fault time series prognosis – Master Thesis Literature Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Master Thesis Literature Review</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.qmd"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../posts/index.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Successive model-agnostic meta-learning for few-shot fault time series prognosis</h1>
                  <div>
        <div class="description">
          메타 러닝 관련 논문 요약 및 주요 내용
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">MetaLearning</div>
                <div class="quarto-category">Survey</div>
                <div class="quarto-category">Review</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>김한울 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 15, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#초록" id="toc-초록" class="nav-link active" data-scroll-target="#초록">초록</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="초록" class="level1">
<h1>초록</h1>
<p>메타러닝은 few-shot 결함 예측 문제를 해결하는 유망한 기술로, 최근 몇 년간 많은 연구자들의 주목을 받아왔습니다. 주로 무작위 및 유사성 매칭 기반의 task 분할에 의존하는 기존의 시계열 예측 메타러닝 방법들은 세 가지 주요 한계에 직면합니다:</p>
<ol type="1">
<li>Feature exploitation inefficiency(특징 활용의 비효율성)<br>
</li>
<li>Suboptimal task data allocation</li>
<li>Limited Robustness with small samples(적은 샘플에서의 제한된 견고성)</li>
</ol>
<p>이러한 한계를 극복하기 위해,</p>
<ol type="1">
<li>본 연구는 시계열의 연속적인 기간을 다수의 연속된 짧은 기간으로 구성된 메타-task로 간주하는 새로운 ‘의사 메타-task(pseudo meta-task)’ 분할 기법을 제안합니다. 연속 시계열을 의사 메타-task로 사용함으로써, 제안하는 방법은 데이터로부터 더 포괄적인 특징과 관계를 추출하여 더 정확한 예측을 할 수 있습니다.<br>
</li>
<li>또한, 여러 데이터셋에 걸쳐 제안 방법의 견고성을 향상시키기 위해 차분(differential) 알고리즘을 도입합니다.</li>
</ol>
<p>여러 결함 및 시계열 예측 데이터셋에 대한 광범위한 실험을 통해, 제안하는 접근법이 few-shot 조건과 일반 조건 모두에서 예측 성능과 일반화 능력을 상당히 향상시킨다는 것을 입증합니다.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p><strong>Fault Prediction in Time series Data</strong><br>
시계열 데이터의 결함 예측은 광범위한 산업적 응용 분야를 가진 매우 중요한 머신러닝 task이지만, 데이터 부족 및 주파수 불일치와 같은 문제점에 직면합니다.</p>
<blockquote class="blockquote">
<p>문제점: Data Scarcity, Frequency Mismatch</p>
</blockquote>
<p>메타러닝은 이러한 문제들을 해결하기 위한 유망한 접근법으로 부상했으며, task 간 유사점과 차이점을 활용하여 새로운 시계열 결함 예측 task에 효과적으로 적응합니다.<br>
이는 딥러닝 모델이 단 몇 개의 샘플 또는 심지어 샘플이 없는 경우에도 새로운 시계열 데이터에 빠르게 적응할 수 있게 하며, 다양한 도메인과 시나리오에서 비롯된 시계열 데이터 간의 유사점과 차이점을 활용하여 일반화 능력을 향상시킵니다([35], [2]).</p>
<blockquote class="blockquote">
<p>메타러닝: cross-task similarities와 differences 활용해 fualt prediction에 적용</p>
</blockquote>
<p>메타러닝은 머신러닝 알고리즘이 ’learning to learn’을 가능하게 하여, 지식의 보편성과 적응성을 향상시킵니다. 시계열 결함 예측 분야에서 메타러닝의 효과는 task-distribution에 의존하는 몇 가지 요인들의 미묘한 보정에 달려 있으며, 연구자들은</p>
<ol type="1">
<li>Data representation (데이터 표현),<br>
</li>
<li>Meta-learner design (메타-러너 설계),<br>
</li>
<li>Meta-learning algorithms (메타러닝 알고리즘),<br>
</li>
<li>Peuso meta-task division (의사 메타-task 분할)</li>
</ol>
<p>이라는 네 가지 핵심 측면을 꼽습니다.<br>
주목할 점은, 첫 세 가지 측면은 특정 task distribution에 따라 다른 조정이 필요한 반면, 의사 메타-task의 분할은 task distribution에 의존하지 않는다는 것입니다 [24]. 따라서, 본 논문은 결함 예측에서 메타러닝의 적응성을 향상시키기 위해 주로 의사 메타-task의 분할 방법을 개선합니다.</p>
<hr>
<p>시계열 예측에서 메타러닝을 위한 task 분할 알고리즘은 크게 두 가지 유형으로 분류할 수 있습니다.</p>
<p><strong>무작위 task 분할 방법:</strong> 이 범주에서 가장 대표적인 방법은 Model-Agnostic Meta-Learning (MAML) [6]으로, 무작위로 시간 구간을 선택하여 의사 메타-task로 사용하는 전략을 사용합니다. MAML++ [1], MetaL [3], Bootstrapped Meta-learning (BMG) [7]과 같은 방법들이 다양한 측면에서 MAML에 대한 훌륭한 발전과 개선을 이루었지만, MAML의 의사 메타-task 분할 접근법을 특별히 개선하지는 않았습니다. <em>시계열을 무작위로 task로 분할하는 특성상, 이 접근법은 시간적 상관관계를 완전히 포착하지 못할 수 있으며, 시계열의 일관성을 잠재적으로 훼손할 수 있습니다.</em></p>
<p><strong>유사성 매칭 기반 task 분할 방법:</strong> 이 범주의 대표적인 방법은 Mo 등이 제안한 것으로[23], 본 논의에서는 이를 ’MAML (DTW)’라고 지칭하겠습니다. 이 방법은 MAML 프레임워크 내에서 동적 시간 워핑(Dynamic Time Warping, DTW)을 사용하여 현재 시간 구간과 가장 유사한 시간 구간들을 의사 메타-task로 선택합니다. 이를 통해 모델의 예측 성능과 견고성을 향상시킵니다. 그러나 이 접근법은 <strong>특히 데이터가 부족한 환경</strong>에서 어려움을 겪습니다. <strong>데이터 품질이 낮을 때</strong> 적절한 데이터 샘플을 찾는 데 어려움을 겪을 수 있습니다. 더 나아가, 시계열에서 충분한 상관관계를 추출하지 못할 수 있습니다.</p>
<blockquote class="blockquote">
<p>기존 Meta-Learning의 Task Paritioning Algorithms의 단점?</p>
<ul>
<li>무작위 방식은 시간적 상관관계를 파괴한다.<br>
</li>
<li>유사성 매칭 방식인 DTW방식은 시간적 상관관계를 포착하려고 시도하지만, 데이터 부족이나 방법론적 한계 때문에 충분하지 않다.</li>
</ul>
</blockquote>
<p>메타러닝이 상당한 발전을 이루었지만, 이 분야 내에서의 task 분할은 비교적 적은 주목을 받아왔습니다.</p>
<ul>
<li>이는 기존 메타러닝 알고리즘의 효과를 제한하고 있을 수 있는 잠재적 약점을 시사합니다.</li>
</ul>
<p>이를 더 잘 이해하기 위해서는, 현재 task 분할 방법들의 작동 방식의 세부 사항을 면밀히 살펴보고 <strong>어떤 부분에서 부족한 지 파악</strong>해야 합니다.</p>
<ol type="1">
<li>현재 방법들은 연속 시계열에 내재된 특징과 의존성을 효과적으로 활용하는 데 어려움을 겪습니다.</li>
</ol>
<ul>
<li>심층 분석에 따르면, 널리 사용되는 Model-Agnostic Meta-Learning(MAML)을 포함한 이러한 방법들의 <strong>대다수가 무작위 task 분할을 사용</strong>한다는 점이 드러났습니다. 이러한 task 분할 접근법은 적용 범위가 넓다는 장점이 있긴 하지만, 본질적으로 연속 시계열을 분리된 세그먼트로 나누어 버린다는 단점이 있습니다. 이러한 단절은 정확한 시계열 예측에 필수적인 중요한 시간적 의존성의 손실을 초래하는 경우가 많습니다 [31].</li>
<li>MAML과 DTW에서 영감을 받아 <strong>유사성 매칭 기반 방법론을 사용하는 대안적인 task 분할 패러다임</strong>이 [23]에서 소개되었습니다. 이 패러다임은 복잡한 시계열 특징과 의존성을 어느 정도 포착하는 데 장점이 있습니다. 그러나, 데이터셋에 유사성 매칭 샘플이 충분하지 않은 시나리오에서는 이 전략의 성능이 무작위 task 분할의 성능으로 수렴하는 경향이 있다는 점에 주목할 필요가 있습니다. 결정적으로, 이 방법은 메타-훈련에 사용되는 시계열을 본질적으로 분리된 세그먼트로 분해하여 장기 의존성을 포착하는 데 한계를 야기합니다.<br>
</li>
</ul>
<ol start="2" type="1">
<li>현재 의사 메타-task의 분할은 종종 차선책에 머물러, 일반화 능력이 제한되고 환경에 따라 성능 편차가 크게 나타납니다. 대표적인 예는 MAML(DTW) [23]의 유사성 매칭 기반 접근법입니다.</li>
</ol>
<ul>
<li>이 방법은 유사한 시간 구간을 task로 묶어 모델 성능을 향상시키는 것을 목표로 합니다. 그럼에도 불구하고, 데이터셋에 조건을 충족하는 샘플이 충분하지 않을 때 그 효과는 약화됩니다. 이러한 경우, 이 방법의 성능은 무작위 task 분할 접근법의 성능에 가까워지는 경향이 있어, 적응성에 한계가 있음을 보여줍니다.</li>
</ul>
<ol start="3" type="1">
<li>이전의 task 분할 메타-러너들은 제한된(limited) 샘플 크기를 다룰 때 견고성이 떨어집니다. 이 문제는 데이터가 부족하거나 드문드문 나타날 수 있는 산업 환경에서 특히 두드러집니다.</li>
</ol>
<ul>
<li>MAML과 그 변형들을 포함한 전통적인 메타러닝 알고리즘들은 이러한 제약 조건 하에서 성능이 현저히 저하됩니다. 이는 최근 연구들에서도 확인된 바(corroborated by recent studies)로, 제한된 샘플이 예외보다는 일반적인 규칙인 실제 시나리오에서는 이러한 알고리즘들이 덜 효과적임을 나타냅니다 [8]. 따라서, task 분할이 받아온 제한된 관심과 희소하거나 누락된 샘플을 처리하는 데 있어서의 현재의 부적절함을 고려할 때, 제한된 샘플 조건 하에서도 높은 성능을 유지하는 견고한 메타러닝 접근법에 대한 명백한 필요성이 있습니다. 이러한 고려 사항은 저희가 이후에 제안할 방법을 설계하는 데 있어 핵심적인 요소입니다.</li>
</ul>
<p><strong>In response to the aforementioned limitations…</strong></p>
<p>few-shot 결함 예측에 특화된 모델 독립적인 메타러닝 접근법인 <strong>Successive Model-Agnostic Meta-Learning (SMAML)</strong>을 소개합니다.</p>
<ul>
<li>SMAML의 핵심은 차분 자기회귀(differential autoregression)에 기반하여 의사 메타-task를 구성하는 방법입니다. 이 방법은 MAML [6]이 제시한 방법에 깊이 영감을 받았으며 그 원리를 한 단계 발전시키고자 합니다.</li>
<li>SMAML의 중심에는 소스 도메인에서 메타러닝을 위해 시간 세그먼트를 연속적으로 추출하는 샘플 선택 방법이 있습니다. 이는 2022년 Mo 등이 제안한 의사 메타-RUL task라는 혁신적인 개념을 기반으로 합니다 [23].</li>
<li>SMAML의 결정적인 특징은 장기 시계열의 미묘한 차이를 통합하여, 더 조밀한 시간적 의존성을 형성하는 능력에 있습니다. 이러한 의존성은 저희 실험에서 few-shot 조건이라고 알려진 어려운 학습 시나리오에서 특히 중추적인 역할을 합니다.</li>
<li>주목할 점은, 이러한 조건들은 소스 도메인과 타겟 도메인이 서로 다른 작동 조건이나 고장 모드(failure modes)를 가지며, 타겟 도메인의 훈련 데이터는 오직 테스트에만 사용되는 시나리오를 의미합니다.</li>
<li>저희가 제안하는 방법을 사용하면 소스 도메인에서 훈련된 모델이 타겟 도메인에서의 예측 정확도를 향상시킬 수 있습니다.</li>
</ul>
<p>SMAML의 다재다능함을 강조하기 위해, 이러한 few-shot 조건과 일반 조건(소스 도메인과 타겟 도메인이 동일한 작동 조건과 고장 모드를 공유하며 훈련 데이터 양이 충분한 경우) 모두에서 비교 테스트를 수행했습니다.</p>
<ul>
<li>제안 방법은 두 조건 모두에서 지속적으로 현저하게 좋은 성능 향상을 기록했습니다. task 분할 방법과 그것이 어떻게 서로 다른 학습 환경에서 작동하는지에 대한 자세한 설명은 4장에서 제공됩니다. 일반 조건에서는 저희 방법이 예측 성능을 더욱 향상시킬 수 있습니다. 이 연구에서 제안된 task 분할 방법의 장점을 검증하기 위해, 저희는 의사 메타-task 분할 접근법만 변경하고 실험 조건은 일정하게 유지했습니다.</li>
</ul>
<p><strong>본 논문의 주요 기여</strong> 본 논문의 주요 기여는 다음과 같이 요약됩니다.</p>
<ol type="1">
<li><strong>연속 시계열에서의 Task 분할 문제 해결</strong>:</li>
</ol>
<p>저희는 의사 메타-task 구성을 위해 차분 자기회귀에 기반한 획기적인 접근법을 소개합니다. 이 방법은 무작위 task 분할과 관련된 내재적인 문제들을 해결하기 위해 세심하게 설계되었습니다. 연속 시계열의 고유한 특징과 의존성을 보존하고 능숙하게 활용함으로써, 저희 접근법은 시계열을 분리된 세그먼트로 단편화하는 방법들이 가진 한계를 극복합니다.</p>
<ol start="2" type="1">
<li><strong>제한된 샘플 조건 하에서의 견고한 메타러닝</strong>:</li>
</ol>
<p>이전 task 분할 메타-러너들의 단점, 특히 제한된 샘플 크기에 직면했을 때의 취약성을 인식하고, 저희가 제안하는 접근법은 견고하게 맞섭니다. 데이터 부족이 시급한 문제인 산업 환경에서, 저희 방법은 견고성과 우수한 성능을 보여줍니다.</p>
<ol start="3" type="1">
<li><strong>SMAML의 다재다능함에 대한 경험적 입증</strong>:</li>
</ol>
<p>벤치마크 데이터셋인 Electricity Transformer Dataset(ETT)을 포함한 여러 산업 결함 데이터셋에 대한 광범위한 평가를 통해, 저희 접근법은 few-shot 학습 시나리오와 전통적인 설정 모두에서 그 우수성을 입증할 뿐만 아니라, 다양한 시계열 데이터셋에 걸쳐 다른 메타러닝 기법들을 일관되게 능가합니다.</p>
<p><strong>본 논문의 구성</strong><br>
본 논문의 나머지 부분은 다음과 같이 구성됩니다.</p>
<ul>
<li>2장에서는 해당 분야의 관련 연구들을 검토합니다.</li>
<li>3장에서는 결함 예측 task를 위한 Successive Model-Agnostic Meta-Learning(SMAML)의 방법론을 상세히 설명합니다.</li>
<li>실험 설정과 결과는 각각 4장과 5장에서 제시되며, 제안된 방법의 효용성을 보여줍니다.</li>
<li>마지막으로 6장에서는 논문을 마무리하며, 기여한 바를 요약하고 향후 연구 방향을 제안합니다.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>