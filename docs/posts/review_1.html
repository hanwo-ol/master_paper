<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김한울">
<meta name="dcterms.date" content="2025-11-22">
<meta name="description" content="참고문헌 1: Portfolio Selection by Harry Markowitz">

<title>Portfolio Selection Harry Markowitz – Master Thesis Literature Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Master Thesis Literature Review</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.qmd"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../posts/index.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Portfolio Selection Harry Markowitz</h1>
                  <div>
        <div class="description">
          참고문헌 1: Portfolio Selection by Harry Markowitz
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Finance</div>
                <div class="quarto-category">Quant</div>
                <div class="quarto-category">Portfolio</div>
                <div class="quarto-category">Review</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>김한울 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 22, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#기본-정의" id="toc-기본-정의" class="nav-link active" data-scroll-target="#기본-정의">기본 정의</a></li>
  <li><a href="#공분산의-정의" id="toc-공분산의-정의" class="nav-link" data-scroll-target="#공분산의-정의">공분산의 정의</a></li>
  <li><a href="#가중합의-기대값과-분산" id="toc-가중합의-기대값과-분산" class="nav-link" data-scroll-target="#가중합의-기대값과-분산">가중합의 기대값과 분산</a></li>
  <li><a href="#개-자산-포트폴리오-모델" id="toc-개-자산-포트폴리오-모델" class="nav-link" data-scroll-target="#개-자산-포트폴리오-모델">3개 자산 포트폴리오 모델</a></li>
  <li><a href="#포트폴리오-선택-원칙" id="toc-포트폴리오-선택-원칙" class="nav-link" data-scroll-target="#포트폴리오-선택-원칙">포트폴리오 선택 원칙</a></li>
  <li><a href="#단순-할인-수익-규칙이-다양화를-설명할-수-없는-이유" id="toc-단순-할인-수익-규칙이-다양화를-설명할-수-없는-이유" class="nav-link" data-scroll-target="#단순-할인-수익-규칙이-다양화를-설명할-수-없는-이유">단순 할인 수익 규칙이 다양화를 설명할 수 없는 이유</a></li>
  <li><a href="#markowitz-포트폴리오-수식의-약점과-개선-포인트" id="toc-markowitz-포트폴리오-수식의-약점과-개선-포인트" class="nav-link" data-scroll-target="#markowitz-포트폴리오-수식의-약점과-개선-포인트">Markowitz 포트폴리오 수식의 약점과 개선 포인트</a>
  <ul class="collapse">
  <li><a href="#논문이-제시한-기본-수식-구조요약" id="toc-논문이-제시한-기본-수식-구조요약" class="nav-link" data-scroll-target="#논문이-제시한-기본-수식-구조요약">1. 논문이 제시한 기본 수식 구조(요약)</a></li>
  <li><a href="#수식가정-자체의-구조적-약점" id="toc-수식가정-자체의-구조적-약점" class="nav-link" data-scroll-target="#수식가정-자체의-구조적-약점">2. 수식/가정 자체의 구조적 약점</a>
  <ul class="collapse">
  <li><a href="#분산-위험-정의의-한계" id="toc-분산-위험-정의의-한계" class="nav-link" data-scroll-target="#분산-위험-정의의-한계">2-1. “분산 = 위험” 정의의 한계</a></li>
  <li><a href="#정규분포평균분산-충분성-가정" id="toc-정규분포평균분산-충분성-가정" class="nav-link" data-scroll-target="#정규분포평균분산-충분성-가정">2-2. 정규분포·평균–분산 충분성 가정</a></li>
  <li><a href="#단일-기간정태적static-상관-구조" id="toc-단일-기간정태적static-상관-구조" class="nav-link" data-scroll-target="#단일-기간정태적static-상관-구조">2-3. 단일 기간·정태적(static) 상관 구조</a></li>
  </ul></li>
  <li><a href="#추정estimation-문제-오차-극대화기-문제" id="toc-추정estimation-문제-오차-극대화기-문제" class="nav-link" data-scroll-target="#추정estimation-문제-오차-극대화기-문제">3. 추정(Estimation) 문제: “오차 극대화기” 문제</a>
  <ul class="collapse">
  <li><a href="#기대수익µ-추정에-대한-극단적인-민감도" id="toc-기대수익µ-추정에-대한-극단적인-민감도" class="nav-link" data-scroll-target="#기대수익µ-추정에-대한-극단적인-민감도">3-1. 기대수익(µ) 추정에 대한 극단적인 민감도</a></li>
  <li><a href="#공분산σ-추정과-차원-저주" id="toc-공분산σ-추정과-차원-저주" class="nav-link" data-scroll-target="#공분산σ-추정과-차원-저주">3-2. 공분산(Σ) 추정과 차원 저주</a></li>
  <li><a href="#과거-데이터-의존성" id="toc-과거-데이터-의존성" class="nav-link" data-scroll-target="#과거-데이터-의존성">3-3. 과거 데이터 의존성</a></li>
  </ul></li>
  <li><a href="#현실-제약과-투자자-행동을-무시하는-한계" id="toc-현실-제약과-투자자-행동을-무시하는-한계" class="nav-link" data-scroll-target="#현실-제약과-투자자-행동을-무시하는-한계">4. 현실 제약과 투자자 행동을 무시하는 한계</a>
  <ul class="collapse">
  <li><a href="#거래비용세금규제유동성-무시" id="toc-거래비용세금규제유동성-무시" class="nav-link" data-scroll-target="#거래비용세금규제유동성-무시">4-1. 거래비용·세금·규제·유동성 무시</a></li>
  <li><a href="#완전-합리위험회피-투자자-가정" id="toc-완전-합리위험회피-투자자-가정" class="nav-link" data-scroll-target="#완전-합리위험회피-투자자-가정">4-2. 완전 합리·위험회피 투자자 가정</a></li>
  </ul></li>
  <li><a href="#이런-약점을-보완하기-위한-주요-개선-포인트" id="toc-이런-약점을-보완하기-위한-주요-개선-포인트" class="nav-link" data-scroll-target="#이런-약점을-보완하기-위한-주요-개선-포인트">5. 이런 약점을 보완하기 위한 주요 개선 포인트</a>
  <ul class="collapse">
  <li><a href="#위험-측정-개선-다운사이드-리스크-var-cvar-등" id="toc-위험-측정-개선-다운사이드-리스크-var-cvar-등" class="nav-link" data-scroll-target="#위험-측정-개선-다운사이드-리스크-var-cvar-등">5-1. 위험 측정 개선: 다운사이드 리스크, VaR, CVaR 등</a></li>
  <li><a href="#추정-리스크-완화-로버스트-최적화bayesian제약-부여" id="toc-추정-리스크-완화-로버스트-최적화bayesian제약-부여" class="nav-link" data-scroll-target="#추정-리스크-완화-로버스트-최적화bayesian제약-부여">5-2. 추정 리스크 완화: 로버스트 최적화·Bayesian·제약 부여</a></li>
  <li><a href="#다기간동적상태전이-모델" id="toc-다기간동적상태전이-모델" class="nav-link" data-scroll-target="#다기간동적상태전이-모델">5-3. 다기간·동적·상태전이 모델</a></li>
  <li><a href="#현실-제약과-비용을-포함한-확장" id="toc-현실-제약과-비용을-포함한-확장" class="nav-link" data-scroll-target="#현실-제약과-비용을-포함한-확장">5-4. 현실 제약과 비용을 포함한 확장</a></li>
  <li><a href="#행동재무머신러닝비선형-모델과의-결합" id="toc-행동재무머신러닝비선형-모델과의-결합" class="nav-link" data-scroll-target="#행동재무머신러닝비선형-모델과의-결합">5-5. 행동재무·머신러닝·비선형 모델과의 결합</a></li>
  </ul></li>
  <li><a href="#정리-수식-자체의-의미와-오늘날의-위치" id="toc-정리-수식-자체의-의미와-오늘날의-위치" class="nav-link" data-scroll-target="#정리-수식-자체의-의미와-오늘날의-위치">6. 정리: “수식 자체”의 의미와 오늘날의 위치</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><strong>포트폴리오 선택 이론</strong>을 다루는 논문입니다. 이 논문은 투자자가 여러 증권(자산) 중에서 어떻게 포트폴리오를 선택해야 하는지를 체계적으로 분석하며, 다음의 주요 내용을 담고 있습니다:</p>
<ul>
<li><strong>포트폴리오 구성 과정</strong>: 투자자는 먼저 각 증권의 미래 수익에 대한 믿음을 형성하고, 그 믿음(기대 수익, 위험)에 따라 포트폴리오를 선택하게 됩니다.</li>
<li><strong>기대수익과 분산(위험)</strong>: 투자자는 기대수익을 높게, 위험(수익의 분산)을 낮게 하는 포트폴리오를 선호해야 하며, 단순히 기대수익만 극대화하는 것은 적절치 않다고 설명합니다.</li>
<li><strong>효율적 포트폴리오</strong>: 기대수익과 분산(위험)의 조합 중 최소 위험으로 기대수익을 최대화하는 ’효율적 포트폴리오’의 개념을 도입합니다.</li>
<li><strong>분산 투자와 상관관계</strong>: 자산을 여러 종목에 분산시켜 투자할 때, 단순히 종목 수를 늘리는 것보다 자산 간의 상관관계(covariance)를 고려한 분산이 중요함을 강조합니다.</li>
<li><strong>수학적 모델 및 그래픽적 설명</strong>: 2~4가지 증권으로 구성된 모델을 통해 효율적 포트폴리오의 선택을 기하학적으로 설명하며, 분산-기대수익 곡선(효율적 경계)을 도출합니다.</li>
<li><strong>실무적 시사점</strong>: 이론적 분석뿐 아니라 실제 투자에서 기대수익과 분산(위험)을 통계적으로 추정하고, 전문가의 판단을 종합해 포트폴리오를 선택할 수 있음을 제시합니다.</li>
</ul>
<p>즉, 이 논문은 오늘날 금융에서 사용되는 <strong>현대 포트폴리오 이론(MPT)</strong>의 토대를 제공하는 핵심 저작으로, 투자자가 위험과 수익 간의 균형을 통해 합리적으로 포트폴리오를 구성해야 함을 설명합니다.</p>
<p>그럼, Markowitz의 포트폴리오 선택 논문의 주요 수식들을 전개하겠습니다.</p>
<section id="기본-정의" class="level2">
<h2 class="anchored" data-anchor-id="기본-정의">기본 정의</h2>
<p>포트폴리오의 기대수익률과 분산은 다음과 같이 정의됩니다.</p>
<p><strong>포트폴리오 기대수익:</strong> <span class="math inline">\(E = \sum_{i=1}^{N} X_i \mu_i\)</span></p>
<p>여기서 <span class="math inline">\(X_i\)</span>는 자산 i에 투자된 비율(가중치), <span class="math inline">\(\mu_i\)</span>는 자산 i의 기대수익입니다.</p>
<p><strong>포트폴리오 분산:</strong> <span class="math inline">\(V = \sum_{i=1}^{N} \sum_{j=1}^{N} X_i X_j \sigma_{ij}\)</span></p>
<p>여기서 <span class="math inline">\(\sigma_{ij}\)</span>는 자산 i와 j 사이의 공분산(covariance)입니다.</p>
</section>
<section id="공분산의-정의" class="level2">
<h2 class="anchored" data-anchor-id="공분산의-정의">공분산의 정의</h2>
<p>자산 i와 j 사이의 공분산은: <span class="math inline">\(\sigma_{ij} = E\left[(R_i - \mu_i)(R_j - \mu_j)\right]\)</span></p>
<p>특별히 <span class="math inline">\(\sigma_{ii}\)</span>는 자산 i의 분산이며, 상관계수(correlation coefficient) <span class="math inline">\(\rho_{ij}\)</span>를 사용하면: <span class="math inline">\(\sigma_{ij} = \rho_{ij} \sigma_i \sigma_j\)</span></p>
</section>
<section id="가중합의-기대값과-분산" class="level2">
<h2 class="anchored" data-anchor-id="가중합의-기대값과-분산">가중합의 기대값과 분산</h2>
<p><span class="math inline">\(R = \sum_{i=1}^{n} a_i R_i\)</span>로 표현되는 가중합에 대해:</p>
<p><strong>기대값:</strong> <span class="math inline">\(E(R) = \sum_{i=1}^{n} a_i E(R_i)\)</span></p>
<p><strong>분산:</strong> <span class="math inline">\(V(R) = \sum_{i=1}^{N} \sum_{j=1}^{N} a_i a_j \sigma_{ij}\)</span></p>
</section>
<section id="개-자산-포트폴리오-모델" class="level2">
<h2 class="anchored" data-anchor-id="개-자산-포트폴리오-모델">3개 자산 포트폴리오 모델</h2>
<p>3개의 자산만 고려하는 경우:</p>
<p><strong>1) 기대수익:</strong> <span class="math inline">\(E = \mu_3 + X_1(\mu_1 - \mu_3) + X_2(\mu_2 - \mu_3)\)</span></p>
<p><strong>2) 분산:</strong></p>
<p><span class="math display">\[V = X_1^2(\sigma_{11} - 2\sigma_{13} + \sigma_{33}) + X_2^2(\sigma_{22} - 2\sigma_{23} + \sigma_{33}) + 2X_1X_2(\sigma_{12} - \sigma_{13} - \sigma_{23} + \sigma_{33}) + 2X_1(\sigma_{13} - \sigma_{33}) + 2X_2(\sigma_{23} - \sigma_{33}) + \sigma_{33}\]</span></p>
<p><strong>3) 제약조건:</strong> <span class="math inline">\(\sum_{i=1}^{3} X_i = 1, \quad X_i \geq 0 \text{ for } i = 1, 2, 3\)</span></p>
</section>
<section id="포트폴리오-선택-원칙" class="level2">
<h2 class="anchored" data-anchor-id="포트폴리오-선택-원칙">포트폴리오 선택 원칙</h2>
<p>Markowitz는 투자자가 다음을 따라야 한다고 제시합니다:</p>
<ul>
<li><strong>기대수익-분산 규칙(E-V Rule)</strong>: 주어진 기대수익 <span class="math inline">\(E\)</span>에 대해 최소 분산 <span class="math inline">\(V\)</span>를 갖거나, 주어진 분산 <span class="math inline">\(V\)</span>에 대해 최대 기대수익 <span class="math inline">\(E\)</span>를 갖는 포트폴리오를 선택해야 함</li>
</ul>
<p>효율적 포트폴리오 집합은 이러한 조건을 만족하는 모든 포트폴리오로 구성되며, 이들이 만드는 곡선을 <strong>효율적 경계(efficient frontier)</strong>라고 합니다.</p>
</section>
<section id="단순-할인-수익-규칙이-다양화를-설명할-수-없는-이유" class="level2">
<h2 class="anchored" data-anchor-id="단순-할인-수익-규칙이-다양화를-설명할-수-없는-이유">단순 할인 수익 규칙이 다양화를 설명할 수 없는 이유</h2>
<p>비교대상으로 제시된 할인 기대수익 극대화 규칙: <span class="math inline">\(R = \sum_{i=1}^{N} X_i R_i\)</span></p>
<p>여기서 <span class="math inline">\(R_i\)</span>는 독립적이고, <span class="math inline">\(\sum X_i = 1\)</span>, <span class="math inline">\(X_i \geq 0\)</span>일 때, 이 규칙은 최대 <span class="math inline">\(R_i\)</span>를 갖는 자산에만 전액 투자하도록 하므로 <strong>다양화를 설명할 수 없습니다</strong>. 반면, E-V 규칙은 공분산을 고려하여 다양화의 이점을 설명할 수 있습니다.</p>
<hr>
</section>
<section id="markowitz-포트폴리오-수식의-약점과-개선-포인트" class="level1">
<h1>Markowitz 포트폴리오 수식의 약점과 개선 포인트</h1>
<p><strong>핵심 요약:</strong><br>
Markowitz 논문의 평균–분산(Mean–Variance) 수식은 현대 포트폴리오 이론의 출발점이지만,<br>
① 분산을 위험으로 보는 정의 자체의 한계,<br>
② 정규분포·단일기간·고정 상관계수 같은 비현실적 가정,<br>
③ 기대수익·공분산 추정치에 대한 극심한 민감도(“오류 극대화기”) 때문에 실제 운용에서는 그대로 쓰기 위험하다는 비판을 받습니다.[1][2][3][4][5]</p>
<p>이 한계를 보완하기 위해 다운사이드 리스크, VaR/CVaR, 로버스트 최적화, Black–Litterman, 다기간·동적 모델, 행동재무 기반 모델 등이 제안되었습니다.[2][5][6][7][8][1]</p>
<hr>
<section id="논문이-제시한-기본-수식-구조요약" class="level2">
<h2 class="anchored" data-anchor-id="논문이-제시한-기본-수식-구조요약">1. 논문이 제시한 기본 수식 구조(요약)</h2>
<p>Markowitz 논문의 핵심 수식은 다음 두 개입니다.</p>
<ul>
<li><p>포트폴리오 기대수익: <span class="math inline">\(E = \sum_{i=1}^{N} X_i \mu_i\)</span></p></li>
<li><p>포트폴리오 분산(위험): <span class="math inline">\(V = \sum_{i=1}^{N} \sum_{j=1}^{N} X_i X_j \sigma_{ij}\)</span></p></li>
</ul>
<p>여기서<br>
<span class="math inline">\(X_i\)</span>: 자산 i의 비중, <span class="math inline">\(\mu_i\)</span>: 자산 i 기대수익, <span class="math inline">\(\sigma_{ij}\)</span>: 자산 i, j의 공분산입니다.[9][10]</p>
<p>투자자는<br>
- 주어진 위험 <span class="math inline">\(V\)</span>에서 <span class="math inline">\(E\)</span>를 최대, 또는<br>
- 주어진 <span class="math inline">\(E\)</span>에서 <span class="math inline">\(V\)</span>를 최소<br>
가 되도록 <span class="math inline">\(X_i\)</span>를 고르는 <strong>평균–분산 최적화</strong> 문제를 풉니다.[10][9]</p>
<hr>
</section>
<section id="수식가정-자체의-구조적-약점" class="level2">
<h2 class="anchored" data-anchor-id="수식가정-자체의-구조적-약점">2. 수식/가정 자체의 구조적 약점</h2>
<section id="분산-위험-정의의-한계" class="level3">
<h3 class="anchored" data-anchor-id="분산-위험-정의의-한계">2-1. “분산 = 위험” 정의의 한계</h3>
<p>Markowitz 수식은 <strong>위험을 분산(또는 표준편차) 하나로 측정</strong>합니다.[2][10]</p>
<p>문제점: - 분산은 “예상 수익률에서의 편차”를 제곱해 평균낸 것이라,<br>
<strong>상승(+ 초과수익)과 하락(– 손실)을 똑같이 “나쁜 변동”으로 처벌</strong>합니다.[7][11][2] → 현실의 투자자는 위쪽 변동(예상보다 많이 버는 것)은 싫어하지 않지만, 수식은 그것도 위험으로 봅니다. - 분산은 주로 분포의 “폭”만 보고, <strong>꼬리(tail)에서의 극단손실(테일 리스크)을 제대로 반영하지 못함</strong>.[11][12][2]</p>
<p>이 때문에, 분산 기반 수식은<br>
- “평균은 같지만, 드물게 큰 손실이 나는 포트폴리오”와<br>
- “자잘한 흔들림만 있지만 큰 손실은 없는 포트폴리오”<br>
를 <strong>동일한 위험 수준으로 평가할 수 있습니다</strong>.[7][2]</p>
</section>
<section id="정규분포평균분산-충분성-가정" class="level3">
<h3 class="anchored" data-anchor-id="정규분포평균분산-충분성-가정">2-2. 정규분포·평균–분산 충분성 가정</h3>
<p>Mean–Variance 수식이 “완전한” 선호를 설명하려면 대개 다음이 전제됩니다.[3][6][1][10][2]</p>
<ul>
<li>자산수익률이 <strong>정규분포</strong><br>
</li>
<li>또는 투자자의 효용이 <strong>2차(Quadratic) 효용 함수</strong></li>
</ul>
<p>현실에서는: - 수익률 분포가 <strong>비대칭(Skew)</strong>, <strong>fat tail(두꺼운 꼬리)</strong> 를 갖고, 블랙스완 이벤트가 잦습니다.[6][12] - 이 경우 평균과 분산 두 개의 수치만으로 투자자의 위험 선호를 다 설명할 수 없습니다.<br>
→ 실제로는 <strong>왜도(skewness), 첨도(kurtosis)</strong> 같은 <strong>3·4차 모멘트</strong>가 중요합니다.[1][6][2]</p>
</section>
<section id="단일-기간정태적static-상관-구조" class="level3">
<h3 class="anchored" data-anchor-id="단일-기간정태적static-상관-구조">2-3. 단일 기간·정태적(static) 상관 구조</h3>
<p>기본 Markowitz 모델은 보통 <strong>단일 기간·정태적 모형</strong>입니다.[3][10][1]</p>
<p>가정: - 한 번의 투자 기간 동안<br>
기대수익 <span class="math inline">\(\mu\)</span>, 공분산 행렬 <span class="math inline">\(\Sigma\)</span>, 상관계수 <span class="math inline">\(\rho_{ij}\)</span>가 <strong>고정</strong><br>
- 기간 말에 한 번 성과를 평가하는 구조</p>
<p>문제: - 현실의 상관계수는 <strong>시장 국면(regime)에 따라 크게 변동</strong>, 특히 위기 때는 “상관계수 1로 수렴”.[5][12][13][14] → 위기 국면에서 “다양화로 위험 분산”이라는 수식상의 이점이 실제로 무너집니다. - 투자·리밸런싱은 실제로 <strong>다기간·동적</strong>으로 일어나는데, 논문 수식은 이런 동학을 반영하지 않습니다.[5][1][3]</p>
<hr>
</section>
</section>
<section id="추정estimation-문제-오차-극대화기-문제" class="level2">
<h2 class="anchored" data-anchor-id="추정estimation-문제-오차-극대화기-문제">3. 추정(Estimation) 문제: “오차 극대화기” 문제</h2>
<p>수식 자체보다 더 치명적인 약점은, <strong>입력값(µ, Σ)을 어떻게 추정하느냐</strong>입니다.</p>
<section id="기대수익µ-추정에-대한-극단적인-민감도" class="level3">
<h3 class="anchored" data-anchor-id="기대수익µ-추정에-대한-극단적인-민감도">3-1. 기대수익(µ) 추정에 대한 극단적인 민감도</h3>
<p>실제로는 µ와 Σ를 과거 데이터로 추정해서 수식에 넣는데,<br>
연구 결과 이때 <strong>기대수익 µ의 추정오차가 치명적으로 크고, 최적화가 이 오차를 증폭</strong>하는 것이 확인되었습니다.[4][1][2][3]</p>
<ul>
<li>“Mean–Variance 최적화는 샘플 평균·공분산으로 풀면 실제 성과가 매우 나쁘다.”<br>
</li>
<li>Michaud(1989)는 이를 <strong>“error maximizer(오차 극대화기)”</strong>라고 부름.[2]</li>
<li>단순 동일비중(1/N) 포트폴리오가 MV 최적화보다 <strong>오히려 나은 성과</strong>를 내는 경우도 많다는 연구가 다수.[4][3][2]</li>
</ul>
<p>이 이유로 <strong>Markowitz 포트폴리오는 이론은 아름답지만, ‘그대로 쓰기엔 위험한 모델’</strong>이라는 평가를 받습니다.[2]</p>
</section>
<section id="공분산σ-추정과-차원-저주" class="level3">
<h3 class="anchored" data-anchor-id="공분산σ-추정과-차원-저주">3-2. 공분산(Σ) 추정과 차원 저주</h3>
<ul>
<li>자산 개수가 N이면 공분산 행렬은 <span class="math inline">\(N(N+1)/2\)</span> 개 파라미터가 필요합니다.<br>
</li>
<li>N이 조금만 커져도 <strong>엄청난 수의 파라미터를 추정해야 하고, 표본 수 대비 차원이 너무 커서 추정이 매우 불안정</strong>해집니다.[10][1][3][5]</li>
</ul>
<p>이 불안정한 추정치가 그대로 수식에 들어가면,<br>
- 극단적으로 <strong>집중·레버리지·숏 포지션</strong>이 생기는 비상식적 해가 자주 나옵니다.[4][5][2]</p>
</section>
<section id="과거-데이터-의존성" class="level3">
<h3 class="anchored" data-anchor-id="과거-데이터-의존성">3-3. 과거 데이터 의존성</h3>
<p>Markowitz 수식은 실무에서 <strong>과거 수익률로 µ, Σ를 추정</strong>하는 방식으로 사용됩니다.[12][13][15][1][7]</p>
<ul>
<li>그러나 “과거 성과는 미래를 보장하지 않는다”는 문구대로,<br>
<strong>레짐 변화·구조적 붕괴</strong>가 일어나면 과거 기반 추정치는 무용지물이 됩니다.[13][14][12]</li>
<li>위기 직전·직후에 상관 구조가 급변하면, 과거 데이터를 기반으로 그린 효율적 경계 자체가 실제와 크게 어긋날 수 있습니다.[8][12][5]</li>
</ul>
</section>
</section>
<section id="현실-제약과-투자자-행동을-무시하는-한계" class="level2">
<h2 class="anchored" data-anchor-id="현실-제약과-투자자-행동을-무시하는-한계">4. 현실 제약과 투자자 행동을 무시하는 한계</h2>
<section id="거래비용세금규제유동성-무시" class="level3">
<h3 class="anchored" data-anchor-id="거래비용세금규제유동성-무시">4-1. 거래비용·세금·규제·유동성 무시</h3>
<p>기본 수식은 다음을 모두 무시합니다.[15][6][1][3][5][10]</p>
<ul>
<li>거래비용, 스프레드, 슬리피지<br>
</li>
<li>세금<br>
</li>
<li>최소 거래단위, 공매도 제한, 레버리지 한도<br>
</li>
<li>유동성 제약(대량 매매 시 가격 충격)</li>
</ul>
<p>→ 이 때문에 논문 속 “최적 포트폴리오”는<br>
실제 시장에서 구현 불가능하거나, 구현하려면 <strong>비용·리스크가 과도</strong>해지는 경우가 많습니다.</p>
</section>
<section id="완전-합리위험회피-투자자-가정" class="level3">
<h3 class="anchored" data-anchor-id="완전-합리위험회피-투자자-가정">4-2. 완전 합리·위험회피 투자자 가정</h3>
<p>Markowitz 모델 및 그 위의 MPT는 보통 다음을 전제합니다.[16][6][8][10]</p>
<ul>
<li>투자자는 <strong>위험회피적(risk-averse), 효용 극대화, 완전 합리적</strong><br>
</li>
<li>완전한 정보, 효율적 시장 가깝게 작동</li>
</ul>
<p>행동재무학 연구에 따르면: - 실제 투자자는 <strong>과신, 손실 회피, 군집행동, 프레이밍 효과</strong> 등 다양한 편향을 보이며,<br>
항상 평균–분산 효용을 극대화하는 선택을 하지 않습니다.[6][8][16] - 많은 기관투자가는 규제·부채구조·평가체계 등 <strong>비수익·비분산 요인</strong>으로 포트폴리오를 결정합니다.[17][8]</p>
<p>즉, <strong>Markowitz 수식은 “어떻게 행동해야 하는가”에 대한 규범적 모델일 뿐, 실제 투자자 행동을 잘 설명하지는 못합니다.</strong>[8][6]</p>
<hr>
</section>
</section>
<section id="이런-약점을-보완하기-위한-주요-개선-포인트" class="level2">
<h2 class="anchored" data-anchor-id="이런-약점을-보완하기-위한-주요-개선-포인트">5. 이런 약점을 보완하기 위한 주요 개선 포인트</h2>
<section id="위험-측정-개선-다운사이드-리스크-var-cvar-등" class="level3">
<h3 class="anchored" data-anchor-id="위험-측정-개선-다운사이드-리스크-var-cvar-등">5-1. 위험 측정 개선: 다운사이드 리스크, VaR, CVaR 등</h3>
<p>분산 대신 또는 분산과 함께 <strong>손실 쪽만 보는 지표</strong>를 사용하는 접근이 발전했습니다.[1][5][6][7][2]</p>
<ol type="1">
<li><strong>세미분산(Semivariance), 하방편차</strong><br>
Markowitz 자신도 이후 저서에서 <strong>세미분산</strong>을 제안했습니다.[2]</li>
</ol>
<ul>
<li><p>목표수익 <span class="math inline">\(R^*\)</span>보다 작은 구간만 고려: <span class="math inline">\(\text{Semivariance} = E\left[\min(R - R^*, 0)^2\right]\)</span></p></li>
<li><p>기대수익이 높아서 생기는 “위쪽 변동”은 처벌하지 않고,<br>
<strong>실제 투자자가 싫어하는 손실 영역만 위험으로 측정</strong>합니다.</p></li>
</ul>
<ol start="2" type="1">
<li><strong>VaR(가치-at-위험), CVaR(조건부 VaR)</strong>[5][6][7][1]</li>
</ol>
<ul>
<li>VaR: “신뢰수준 <span class="math inline">\(1-\alpha\)</span>에서의 최대 손실”<br>
</li>
<li>CVaR: 그 손실을 넘는 구간에서의 <strong>평균 손실</strong><br>
</li>
<li>수식적으로 CVaR 최소화 문제는 선형계획법으로 풀 수 있어, 대규모 포트폴리오에 적합합니다.[5]</li>
</ul>
<ol start="3" type="1">
<li><strong>Lower Partial Moments, Omega Ratio 등</strong>[6][1][5]</li>
</ol>
<ul>
<li>특정 기준 이하의 모멘트만 고려하는 <strong>LPM</strong><br>
</li>
<li>수익분포 전체를 보되, 손실 쪽에 더 가중치를 두는 <strong>Omega 비율</strong> 등</li>
</ul>
<p>이들은 Markowitz의 <span class="math inline">\(V\)</span> 대신, 또는 <span class="math inline">\(V\)</span>와 함께 사용되어 <strong>“위험 = 변동성”이라는 단순화의 약점을 줄이는 방향</strong>입니다.</p>
</section>
<section id="추정-리스크-완화-로버스트-최적화bayesian제약-부여" class="level3">
<h3 class="anchored" data-anchor-id="추정-리스크-완화-로버스트-최적화bayesian제약-부여">5-2. 추정 리스크 완화: 로버스트 최적화·Bayesian·제약 부여</h3>
<p>Mean–Variance 수식 자체는 그대로 두고, <strong>µ·Σ의 추정오차에 덜 민감하게 만드는</strong> 방향의 연구가 많이 이루어졌습니다.[18][3][8][1][4][5][2]</p>
<ol type="1">
<li><strong>로버스트(robust) 최적화</strong>[18][5]</li>
</ol>
<ul>
<li>µ와 Σ가 어떤 “불확실성 집합(uncertainty set)” 안에서 변할 수 있다고 보고,<br>
최악의 경우에도 성능이 크게 나쁘지 않은 포트폴리오를 선택</li>
<li>예: 박스(box)·타원체(ellipsoidal)·버짓(budget) 불확실성 집합 위에서의 Mean–Variance 문제[5]</li>
</ul>
<ol start="2" type="1">
<li><strong>Black–Litterman 모형</strong>[1][5]</li>
</ol>
<ul>
<li><strong>시장 균형 수익률(시장 포트폴리오가 효율적이라는 가정)</strong>과<br>
투자자의 주관적 견해(view)를 <strong>Bayesian 방식으로 결합</strong><br>
</li>
<li>Markowitz 수식에 들어가는 µ를 <strong>더 안정적이고 직관적인 값</strong>으로 만들어,<br>
극단적 비중 해를 줄이는 효과</li>
</ul>
<ol start="3" type="1">
<li><strong>공분산 추정 개선: Shrinkage, Factor Model, Regularization</strong>[3][1][2][5]</li>
</ol>
<ul>
<li>샘플 공분산을 단순히 쓰지 않고,
<ul>
<li>Shrinkage(표본 공분산을 구조적 행렬 toward로 수축)<br>
</li>
<li>요인모형(시장·스타일·섹터 팩터)을 사용해 차원 축소<br>
</li>
<li>L2/L1 정규화로 비중에 패널티를 주어 극단해 방지<br>
</li>
</ul></li>
<li>이렇게 추정한 Σ를 Markowitz 수식에 넣으면 <strong>out-of-sample 성능이 개선</strong>됨.</li>
</ul>
<ol start="4" type="1">
<li><strong>제약 있는 Mean–Variance 최적화</strong>[10][1][2][5]</li>
</ol>
<ul>
<li>비중 상·하한, 섹터·자산군 한도, 턴오버 제약 등 현실적 제약을 추가<br>
</li>
<li>극단적 레버리지·숏 비중을 막고, 오차 증폭 문제를 완화</li>
</ul>
</section>
<section id="다기간동적상태전이-모델" class="level3">
<h3 class="anchored" data-anchor-id="다기간동적상태전이-모델">5-3. 다기간·동적·상태전이 모델</h3>
<p>단일 기간 정태 모형이라는 한계를 극복하기 위한 접근입니다.[12][18][3][1][5]</p>
<ul>
<li><strong>다기간 포트폴리오 선택</strong>: 반복 리밸런싱을 고려, 동적 프로그래밍·Stochastic control 등 사용<br>
</li>
<li><strong>레짐 전환(regime-switching) 모델</strong>:
<ul>
<li>정상 국면/위기 국면 등 상태에 따라 µ·Σ·ρ가 달라진다고 가정<br>
</li>
<li>상태 전이 확률 기반으로 포트폴리오 구성<br>
</li>
</ul></li>
<li><strong>타임베어링 상관·변동성 모델(GARCH, DCC 등)</strong>을 이용해,<br>
Markowitz 수식의 입력값을 <strong>시간에 따라 업데이트</strong>하는 식으로 개선[5]</li>
</ul>
<p>즉, 수식 형식(평균–분산)은 유지하되, <strong>µ·Σ를 동적으로 추정·업데이트</strong>하는 방향입니다.</p>
</section>
<section id="현실-제약과-비용을-포함한-확장" class="level3">
<h3 class="anchored" data-anchor-id="현실-제약과-비용을-포함한-확장">5-4. 현실 제약과 비용을 포함한 확장</h3>
<p>기본 Markowitz 문제에 다음을 직접 수식으로 포함시킨 모델들이 발전했습니다.[3][10][1][5]</p>
<ul>
<li><strong>거래비용</strong>: 비중 변화 <span class="math inline">\(|X_i^{(t)} - X_i^{(t-1)}|\)</span>에 비례하는 비용항을 목적함수에 추가<br>
</li>
<li><strong>세금</strong>: 실현이익에 대한 세금을 명시적으로 반영<br>
</li>
<li><strong>유동성 제약</strong>: 거래량 한도, 가격충격 함수 포함<br>
</li>
<li><strong>규제 제약</strong>: VAR 레귤레이션, 레버리지/숏 제한을 명시적 제약식으로 모델링</li>
</ul>
<p>결과적으로는 <span class="math inline">\(\min_{X} \; \lambda V(X) - (1-\lambda)E(X) + \text{Costs}(X)\)</span> 같은 식으로 확장됩니다.</p>
</section>
<section id="행동재무머신러닝비선형-모델과의-결합" class="level3">
<h3 class="anchored" data-anchor-id="행동재무머신러닝비선형-모델과의-결합">5-5. 행동재무·머신러닝·비선형 모델과의 결합</h3>
<p>Markowitz 수식이 전제한 “완전합리·정규분포·선형결합” 가정을 완화하려는 흐름입니다.[17][12][6][1][5]</p>
<ul>
<li><strong>행동 포트폴리오 이론(Behavioral Portfolio Theory, BPT)</strong>:
<ul>
<li>투자자가 여러 “정신적 계좌(mental accounts)”와 비선형 효용을 가진다고 보고,<br>
</li>
<li>평균–분산 대신 비대칭·구간별 효용을 최적화</li>
</ul></li>
<li><strong>머신러닝 기반 자산배분</strong>:
<ul>
<li>딥러닝, 강화학습 등으로 리스크·수익 예측과 포트폴리오 의사결정을 비선형 함수로 모델링<br>
</li>
<li>Markowitz의 선형·이차형 수식에서 벗어나, 고차원 패턴을 포착하려는 시도[6][1][5]</li>
</ul></li>
<li><strong>복잡한 분포 모형(코퓰라 등)</strong>:
<ul>
<li>정규공분산 구조 대신, fat tail·비대칭 상관을 반영하는 joint distribution으로부터<br>
</li>
<li>VaR/CVaR, LPM 등을 계산해 최적화</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="정리-수식-자체의-의미와-오늘날의-위치" class="level2">
<h2 class="anchored" data-anchor-id="정리-수식-자체의-의미와-오늘날의-위치">6. 정리: “수식 자체”의 의미와 오늘날의 위치</h2>
<ul>
<li>Markowitz 논문의 수식은<br>
자산수익률의 <strong>기대값과 공분산을 통해 포트폴리오 위험·수익을 정량화</strong>하고,<br>
이를 최적화 문제로 표현했다는 점에서 여전히 <strong>이론적 기준점</strong>입니다.[9][10]</li>
<li>다만
<ul>
<li>분산 하나로 위험을 정의하는 단순화,<br>
</li>
<li>정규분포·단일기간·정태 상관 구조,<br>
</li>
<li>µ·Σ 추정치에 대한 극심한 민감도,<br>
</li>
<li>거래비용·세금·행동요인 무시<br>
등으로 인해 <strong>그대로 쓰기에는 실무적·경험적 한계가 크다</strong>는 것이 현재 공통된 평가입니다.[14][16][8][12][4][1][3][6][2][5]</li>
</ul></li>
</ul>
<p>그래서 현대의 많은 모델들은<br>
- 기본 틀(“기대수익과 위험의 트레이드오프를 정량화하고 최적화한다”)은 Markowitz 수식을 유지하되,<br>
- 위험 정의, 추정 방법, 동적 구조, 제약조건, 투자자 행동 모형을 <strong>점진적으로 바꿔가며 보완</strong>하는 방향으로 발전해 왔다고 볼 수 있습니다.[8][1][6][2][5]</p>
<p><a href="https://ec-undp-electoralassistance.org/Download_PDFS/scholarship/chQTIu/Markowitz%20Portfolio%20Theory.pdf">1</a> <a href="https://bookdown.org/palomar/portfoliooptimizationbook/7.5-MVP-drawbacks.html">2</a> <a href="https://www.uni-hohenheim.de/fileadmin/einrichtungen/bank/Portfoliomanagement/Lecture_I.pdf">3</a> <a href="https://www.sciencedirect.com/science/article/abs/pii/S0377221721009863">4</a> <a href="https://optimization-online.org/wp-content/uploads/2021/03/8310-1.pdf">5</a> <a href="https://pdfs.semanticscholar.org/4397/43f4775dd14c1d97d1b54fd148a5db38145f.pdf">6</a> <a href="https://www.realized1031.com/blog/what-are-the-benefits-cons-and-limitations-of-modern-portfolio-theory">7</a> <a href="https://caia.org/blog/2021/10/14/challenging-modern-portfolio-theory">8</a> <a href="https://www.math.hkust.edu.hk/~maykwok/courses/ma362/07F/markowitz_JF.pdf">9</a> <a href="https://en.wikipedia.org/wiki/Markowitz_model">10</a> <a href="https://www.britannica.com/money/modern-portfolio-theory-explained">11</a> <a href="https://www.riverbendinvestments.com/the-problem-with-modern-portfolio-theory/">12</a> <a href="https://www.realized1031.com/blog/what-are-the-advantages-and-limitations-of-the-markowitz-model">13</a> <a href="https://www.simtrade.fr/blog_simtrade/modern-portfolio-theory-limitations/">14</a> <a href="https://www.scribd.com/document/647522579/Disadvantages-of-the-Modern-Portfolio-Theory">15</a> <a href="https://www.investopedia.com/managing-wealth/modern-portfolio-theory-why-its-still-hip/">16</a> <a href="https://johnrothe.com/the-problem-with-modern-portfolio-theory/">17</a> <a href="https://www.sciencedirect.com/science/article/abs/pii/S0096300303011263">18</a> <a href="https://drpress.org/ojs/index.php/HBEM/article/view/4991/4838">19</a> <a href="https://www.investopedia.com/terms/c/capm.asp">20</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>