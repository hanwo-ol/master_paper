<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>bayesmetalearning – Master Thesis Literature Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Master Thesis Literature Review</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../posts/index.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#석사-학위-논문-연구-계획서" id="toc-석사-학위-논문-연구-계획서" class="nav-link active" data-scroll-target="#석사-학위-논문-연구-계획서">석사 학위 논문 연구 계획서</a>
  <ul class="collapse">
  <li><a href="#연구-주제" id="toc-연구-주제" class="nav-link" data-scroll-target="#연구-주제">1. 연구 주제</a></li>
  <li><a href="#연구-배경-및-필요성" id="toc-연구-배경-및-필요성" class="nav-link" data-scroll-target="#연구-배경-및-필요성">2. 연구 배경 및 필요성</a></li>
  <li><a href="#선행-연구-및-이론적-배경" id="toc-선행-연구-및-이론적-배경" class="nav-link" data-scroll-target="#선행-연구-및-이론적-배경">3. 선행 연구 및 이론적 배경</a>
  <ul class="collapse">
  <li><a href="#meta-learning-개요-및-taxonomy" id="toc-meta-learning-개요-및-taxonomy" class="nav-link" data-scroll-target="#meta-learning-개요-및-taxonomy">3.1 Meta-learning 개요 및 taxonomy</a></li>
  <li><a href="#gradient-based-meta-learning" id="toc-gradient-based-meta-learning" class="nav-link" data-scroll-target="#gradient-based-meta-learning">3.2 Gradient-based meta-learning</a></li>
  <li><a href="#bayesian-meta-learning" id="toc-bayesian-meta-learning" class="nav-link" data-scroll-target="#bayesian-meta-learning">3.3 Bayesian meta-learning</a></li>
  <li><a href="#gaussian-process-기반-meta-learning-및-pac-bayesian-meta-learning-이론" id="toc-gaussian-process-기반-meta-learning-및-pac-bayesian-meta-learning-이론" class="nav-link" data-scroll-target="#gaussian-process-기반-meta-learning-및-pac-bayesian-meta-learning-이론">3.4 Gaussian process 기반 meta-learning 및 PAC-Bayesian meta-learning 이론</a></li>
  <li><a href="#task-similarity-기반-bayesianmeta-learning" id="toc-task-similarity-기반-bayesianmeta-learning" class="nav-link" data-scroll-target="#task-similarity-기반-bayesianmeta-learning">3.5 Task similarity 기반 Bayesian/meta-learning</a></li>
  </ul></li>
  <li><a href="#연구-목적-및-연구-질문" id="toc-연구-목적-및-연구-질문" class="nav-link" data-scroll-target="#연구-목적-및-연구-질문">4. 연구 목적 및 연구 질문</a>
  <ul class="collapse">
  <li><a href="#연구-목적" id="toc-연구-목적" class="nav-link" data-scroll-target="#연구-목적">4.1 연구 목적</a></li>
  <li><a href="#구체적-연구-질문" id="toc-구체적-연구-질문" class="nav-link" data-scroll-target="#구체적-연구-질문">4.2 구체적 연구 질문</a></li>
  </ul></li>
  <li><a href="#연구-내용-및-방법" id="toc-연구-내용-및-방법" class="nav-link" data-scroll-target="#연구-내용-및-방법">5. 연구 내용 및 방법</a>
  <ul class="collapse">
  <li><a href="#기본-모형-설정" id="toc-기본-모형-설정" class="nav-link" data-scroll-target="#기본-모형-설정">5.1 기본 모형 설정</a></li>
  <li><a href="#제안-prior-구조-task-similarity-기반-공분산" id="toc-제안-prior-구조-task-similarity-기반-공분산" class="nav-link" data-scroll-target="#제안-prior-구조-task-similarity-기반-공분산">5.2 제안 prior 구조: task similarity 기반 공분산</a></li>
  <li><a href="#이론적-분석-계획" id="toc-이론적-분석-계획" class="nav-link" data-scroll-target="#이론적-분석-계획">5.3 이론적 분석 계획</a></li>
  <li><a href="#시뮬레이션-및-실증-연구-계획" id="toc-시뮬레이션-및-실증-연구-계획" class="nav-link" data-scroll-target="#시뮬레이션-및-실증-연구-계획">5.4 시뮬레이션 및 실증 연구 계획</a></li>
  </ul></li>
  <li><a href="#기대-효과-및-학문적-기여" id="toc-기대-효과-및-학문적-기여" class="nav-link" data-scroll-target="#기대-효과-및-학문적-기여">6. 기대 효과 및 학문적 기여</a></li>
  <li><a href="#연구-일정-예시-석사-3학기-기준" id="toc-연구-일정-예시-석사-3학기-기준" class="nav-link" data-scroll-target="#연구-일정-예시-석사-3학기-기준">7. 연구 일정 (예시: 석사 3학기 기준)</a></li>
  <li><a href="#참고-문헌-예시" id="toc-참고-문헌-예시" class="nav-link" data-scroll-target="#참고-문헌-예시">8. 참고 문헌 (예시)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="석사-학위-논문-연구-계획서" class="level1">
<h1>석사 학위 논문 연구 계획서</h1>
<section id="연구-주제" class="level2">
<h2 class="anchored" data-anchor-id="연구-주제">1. 연구 주제</h2>
<p><strong>국문 제목</strong><br>
Task 간 유사도를 반영한 계층 베이지안 메타러닝 prior의 일반적 구성과 통계적 성질</p>
<p><strong>영문 제목</strong><br>
A General Prior Design Incorporating Task Similarity in Hierarchical Bayesian Meta-Learning and Its Statistical Properties</p>
<hr>
</section>
<section id="연구-배경-및-필요성" class="level2">
<h2 class="anchored" data-anchor-id="연구-배경-및-필요성">2. 연구 배경 및 필요성</h2>
<p>딥러닝 기반 모델은 대규모 데이터와 연산 자원을 요구하며, 새로운 task가 등장할 때마다 학습을 처음부터 반복해야 한다는 한계를 가진다. 이를 극복하기 위해 등장한 <strong>meta-learning(learning to learn)</strong> 은 여러 task로부터 축적된 경험을 이용하여, 새로운 task에 대한 빠른 적응과 데이터 효율적 학습을 목표로 한다.</p>
<p>최근 meta-learning 연구는 few-shot 이미지 분류, 강화학습, 베이지안 신경망 등 다양한 응용에서 활발히 진행되고 있으며, 특히 여러 task 간의 공통 구조를 활용하는 <strong>계층 베이지안(hierarchical Bayes)</strong> 및 <strong>Gaussian process(GP) 기반 meta-learning</strong> 이 주목받고 있다.</p>
<p>그러나 기존 Bayesian/meta-learning 연구들은 다음과 같은 한계를 가진다.</p>
<ol type="1">
<li><strong>Task 유사도 구조의 모형화 부족</strong>
<ul>
<li>많은 meta-learning 알고리즘은 암묵적으로 “task들이 유사하다”는 가정을 갖고 있으나,<br>
유사도를 <strong>명시적인 prior 공분산 구조</strong>로 표현하고 그 통계적 효과를 분석한 연구는 제한적이다.</li>
</ul></li>
<li><strong>선형–가우시안 계층 모형에서의 이론적 분석 부족</strong>
<ul>
<li>GP 기반 meta-learning은 task 간 커널을 제안하고 실험적으로 성능 향상을 보이지만,<br>
단순한 선형 회귀/가우시안 노이즈 환경에서<br>
<strong>task similarity를 반영한 prior와 독립 prior의 Bayes risk를 비교·정량화하는 통계적 연구</strong>는 상대적으로 부족하다.</li>
</ul></li>
<li><strong>Meta-learning 이론(예: PAC-Bayes bound)과 구체적 prior 구조의 연결 부족</strong>
<ul>
<li>PAC-Bayesian meta-learning은 hyper-posterior의 최적 구조(PACOH)를 제시하지만,<br>
구체적인 task similarity 기반 prior가 이러한 이론적 틀 안에서 어떤 효과를 가지는지에 대한 정량적 논의는 제한적이다.</li>
</ul></li>
</ol>
<p>본 연구는 이러한 한계를 해결하고자, <strong>task 간 유사도를 반영한 계층 베이지안 meta-learning prior의 일반적 구조를 제안</strong>하고,<br>
<strong>선형–가우시안 계층 모형에서의 Bayes risk 및 학습 곡선(learning curve) 관점에서 그 통계적 성질을 분석하는 것</strong>을 목표로 한다.</p>
<hr>
</section>
<section id="선행-연구-및-이론적-배경" class="level2">
<h2 class="anchored" data-anchor-id="선행-연구-및-이론적-배경">3. 선행 연구 및 이론적 배경</h2>
<section id="meta-learning-개요-및-taxonomy" class="level3">
<h3 class="anchored" data-anchor-id="meta-learning-개요-및-taxonomy">3.1 Meta-learning 개요 및 taxonomy</h3>
<p>Meta-learning은 여러 task로부터 “학습 알고리즘 자체” 또는 “초기 파라미터/표현”을 학습하여, 새로운 task에 빠르게 적응하는 것을 목표로 한다. Hospedales et al.은 meta-learning을 정리하면서, meta-train / meta-test 분할, N-way K-shot 설정, task 분포 <span class="math inline">\(\mathcal{T}\)</span> 등의 표준 수학적 세팅을 제시하고, 다양한 방법론을 포괄하는 taxonomy를 제안하였다.</p>
<p>일반적으로 meta-learning은 다음과 같이 정식화된다.</p>
<ul>
<li>Task 분포 <span class="math inline">\(\mathcal{T}\)</span> 에서 task <span class="math inline">\(t\)</span>를 샘플: <span class="math display">\[
t \sim \mathcal{T}, \quad D_t = \{(x_{ti}, y_{ti})\}_{i=1}^{n_t}
\]</span></li>
<li>Meta-train 단계에서 여러 <span class="math inline">\(t=1,\dots,T\)</span> 에 대해 데이터를 관측하고,</li>
<li>새로운 task <span class="math inline">\(t^\*\)</span> 에 대한 적은 양의 데이터로 빠르게 적응하는 meta-learner를 학습한다.</li>
</ul>
<p>Hospedales et al.의 taxonomy에 따르면, meta-learning 방법은 크게<br>
(1) optimization-based, (2) metric-based, (3) model-based, (4) Bayesian/probabilistic 기반 방법으로 나눌 수 있다.<br>
본 연구는 이 중 <strong>Bayesian/probabilistic meta-learning</strong> 축에 속한다.</p>
<hr>
</section>
<section id="gradient-based-meta-learning" class="level3">
<h3 class="anchored" data-anchor-id="gradient-based-meta-learning">3.2 Gradient-based meta-learning</h3>
<p>Optimization-based meta-learning의 대표적 예로 <strong>MAML(Model-Agnostic Meta-Learning)</strong> 계열이 있다. 이들은 모델 파라미터의 초기값 <span class="math inline">\(\phi\)</span> 를 meta-level에서 학습하고, 각 task별로 서버럴 스텝의 gradient descent를 통해 적응한다. 이러한 방법들은 다양한 신경망 구조에 적용이 가능하고, 구현이 상대적으로 간단하다는 장점이 있어 few-shot 학습에서 널리 사용된다.</p>
<p>Grant et al.는 <strong>“Recasting Gradient-Based Meta-Learning as Hierarchical Bayes”</strong> 에서 MAML과 같은 gradient-based meta-learning이, 적당한 근사 하에서 <strong>계층 베이지안 추론의 한 형태</strong>로 해석될 수 있음을 보였다.<br>
즉, meta-parameter는 상위 계층의 hyperparameter, inner-loop 업데이트는 task-specific posterior mode 추정에 해당한다.</p>
<p>또한, Zou &amp; Lu는 <strong>Gradient-EM Bayesian Meta-Learning</strong> 을 통해 계층 베이지안 모형에서 empirical Bayes 추정을 수행하는 gradient-EM 기반 meta-learning 알고리즘을 제안하고, 기존 gradient-based meta-learning 알고리즘을 하나의 Bayesian 틀 안에서 통합하여 해석하였다.</p>
<p>이러한 연구들은 <strong>gradient-based meta-learning과 계층 베이지안 추론 간의 연결</strong>을 보여주지만,<br>
task 유사도 구조를 공분산으로 명시적으로 모델링하고 그 통계적 성질을 분석하는 데에는 초점을 두지 않는다.</p>
<hr>
</section>
<section id="bayesian-meta-learning" class="level3">
<h3 class="anchored" data-anchor-id="bayesian-meta-learning">3.3 Bayesian meta-learning</h3>
<p>Bayesian meta-learning은 여러 task의 데이터를 이용하여 <strong>prior 또는 hyperparameter를 empirical Bayes/fully Bayes 방식으로 추정</strong>하고, 새로운 task에 대해 불확실성 추정을 포함한 적응을 수행한다.</p>
<p>일반적인 계층 베이지안 meta-learning 모형은 다음과 같이 표현할 수 있다.</p>
<p><span class="math display">\[
\begin{aligned}
\eta &amp;\sim p(\eta), \\
\theta_t \mid \eta &amp;\sim p(\theta_t \mid \eta), \quad t = 1,\dots,T, \\
D_t \mid \theta_t &amp;\sim p(D_t \mid \theta_t),
\end{aligned}
\]</span></p>
<p>여기서 <span class="math inline">\(\eta\)</span> 는 상위 계층의 hyperparameter, <span class="math inline">\(\theta_t\)</span> 는 task-specific 파라미터이다.<br>
Gradient-EM Bayesian meta-learning과 관련 연구들은 이러한 구조에서<br>
<span class="math inline">\(\eta\)</span> 를 empirical Bayes 방식으로 추정하는 다양한 알고리즘과 이론적 성질을 제시하였다.</p>
<p>그러나 Bayesian meta-learning 문헌의 상당수는 <strong>hyperparameter 추정 알고리즘과 실험적 성능</strong>에 집중하며,<br>
task 간 유사도 구조가 prior 공분산에 어떻게 반영되며, 이로 인해 <strong>Bayes risk와 pooling 정도가 어떻게 변하는지에 대한 체계적 분석</strong>은 상대적으로 부족하다.</p>
<hr>
</section>
<section id="gaussian-process-기반-meta-learning-및-pac-bayesian-meta-learning-이론" class="level3">
<h3 class="anchored" data-anchor-id="gaussian-process-기반-meta-learning-및-pac-bayesian-meta-learning-이론">3.4 Gaussian process 기반 meta-learning 및 PAC-Bayesian meta-learning 이론</h3>
<section id="gp-기반-meta-learning" class="level4">
<h4 class="anchored" data-anchor-id="gp-기반-meta-learning">3.4.1 GP 기반 meta-learning</h4>
<p>Gaussian process(GP)는 함수 공간의 베이지안 prior로서, 불확실성을 자연스럽게 표현할 수 있다는 장점이 있다. Nguyen et al.은 <strong>“Learning to Learn with Gaussian Processes”</strong>에서 few-shot 회귀 문제를 위해 <strong>Gaussian Process Meta-Learning(GPML)</strong> 을 제안하였으며, task 간 거리를 이용한 <strong>novel task kernel</strong> 을 도입하여 meta-learning 환경에서 task 간 유사도를 활용하였다.</p>
<p>이와 유사한 GP 기반 meta-learning 연구들은, multi-task GP, deep kernel GP, variational GP 등의 구조를 활용하여 task 간 공유 정보를 모델링하고 few-shot 상황에서 성능 향상을 보였다.</p>
<p>또한 Ashton &amp; Sollich은 <strong>“Learning curves for multi-task Gaussian process regression”</strong>에서<br>
<strong>multi-task GP 회귀의 평균 Bayes error(learning curve)</strong> 를 분석하여, task 간 공분산 구조가 학습 곡선에 미치는 영향을 정량적으로 연구하였다.<br>
이는 본 연구에서 계획하는 <strong>task similarity 기반 prior의 Bayes risk 분석</strong>과 직접적인 수학적 연관이 있다.</p>
</section>
<section id="pac-bayesian-meta-learning" class="level4">
<h4 class="anchored" data-anchor-id="pac-bayesian-meta-learning">3.4.2 PAC-Bayesian meta-learning</h4>
<p>Rothfuss et al.은 <strong>“Scalable PAC-Bayesian Meta-Learning via the PAC-Optimal Hyper-Posterior (PACOH)”</strong>에서<br>
meta-learning의 generalization error에 대한 PAC-Bayesian upper bound를 유도하고, 이를 최소화하는 <strong>PAC-optimal hyper-posterior (PACOH)</strong> 를 도출하였다.<br>
PACOH는 GP, Bayesian neural network 등 다양한 base learner에 적용 가능하며, meta-level regularization을 이론적으로 정당화한다.</p>
<p>PAC-Bayesian meta-learning 이론은 meta-level에서의 최적 prior/hyper-posterior 구조에 대한 중요한 통찰을 제공하지만,<br>
구체적인 <strong>task similarity 기반 공분산 구조</strong>가 이러한 bound에 어떤 영향을 주는지에 대한 분석은 제한적이다.</p>
<hr>
</section>
</section>
<section id="task-similarity-기반-bayesianmeta-learning" class="level3">
<h3 class="anchored" data-anchor-id="task-similarity-기반-bayesianmeta-learning">3.5 Task similarity 기반 Bayesian/meta-learning</h3>
<p>Multi-task learning 및 GP 기반 모델에서는 오래전부터 <strong>task 간 유사도</strong>를 공분산 구조로 표현해 왔다.<br>
예를 들어, multi-task GP에서는 입력 커널 <span class="math inline">\(K_x\)</span>와 task 간 공분산 <span class="math inline">\(\Sigma_{\text{task}}\)</span>의 곱으로 전체 공분산을 구성한다.</p>
<p><span class="math display">\[
K((x,s), (x',t)) = K_x(x, x') \cdot \Sigma_{\text{task}}(s,t).
\]</span></p>
<p>여기서 <span class="math inline">\(\Sigma_{\text{task}}\)</span>는 task 간 유사도/상관을 반영하는 행렬이다.</p>
<p>Nguyen et al.의 GPML은 task 간 거리를 활용한 <strong>task kernel</strong> 을 제안하여, meta-learning 환경에서 task similarity를 명시적으로 모델링한다.<br>
또한 다양한 multi-task GP, hierarchical GP 연구에서는 task feature, 그래프 구조, 군집 등을 이용한 공분산 설계를 시도하고 있다.</p>
<p>하지만 이들 연구는 주로 <strong>복잡한 GP 구조 및 대규모 실험에 기반한 모델 제안</strong>에 집중하며,<br>
단순한 선형–가우시안 계층 모형에서</p>
<ul>
<li><ol type="1">
<li>task similarity를 반영한 prior 공분산 구조가 어떤 조건 하에서 유효한지,<br>
</li>
</ol></li>
<li><ol start="2" type="1">
<li>독립 prior 대비 Bayes risk 및 learning curve가 어떻게 달라지는지</li>
</ol></li>
</ul>
<p>를 <strong>이론적으로 분석하는 통계적 연구는 상대적으로 부족</strong>하다.</p>
<p>따라서 본 연구는, <strong>선형–가우시안 계층 베이지안 meta-learning 모형</strong>을 기반으로<br>
<strong>task similarity 기반 prior 구조를 일반적으로 정의하고, Bayes risk 및 pooling 구조를 수학적으로 분석</strong>함으로써,<br>
기존 문헌의 공백을 메우고자 한다.</p>
<hr>
</section>
</section>
<section id="연구-목적-및-연구-질문" class="level2">
<h2 class="anchored" data-anchor-id="연구-목적-및-연구-질문">4. 연구 목적 및 연구 질문</h2>
<section id="연구-목적" class="level3">
<h3 class="anchored" data-anchor-id="연구-목적">4.1 연구 목적</h3>
<ol type="1">
<li><strong>Task 간 유사도를 반영하는 일반적인 계층 베이지안 meta-learning prior 구조 제안</strong><br>
</li>
<li><strong>선형–가우시안 계층 모형에서 similarity-aware prior와 독립 prior의 Bayes risk 및 학습 곡선 비교 분석</strong><br>
</li>
<li><strong>제안 prior 구조의 이론적 성질(유효성, risk 개선 조건 등)을 정리하고, 시뮬레이션 및 실증으로 검증</strong></li>
</ol>
</section>
<section id="구체적-연구-질문" class="level3">
<h3 class="anchored" data-anchor-id="구체적-연구-질문">4.2 구체적 연구 질문</h3>
<ul>
<li><p><strong>RQ1.</strong> Task feature 또는 task 간 거리/그래프 정보를 이용하여,<br>
계층 베이지안 meta-learning에서 일반적으로 사용할 수 있는 <strong>task similarity 기반 prior 공분산 구조</strong>를 어떻게 정의할 수 있는가?</p></li>
<li><p><strong>RQ2.</strong> 선형 회귀 + 가우시안 노이즈 환경에서,<br>
similarity-aware prior와 독립 prior에 기반한 meta-learning의 <strong>Bayes risk</strong>는 어떻게 비교되는가?<br>
특히 어떤 조건(유사도 구조가 실제 task 관계를 잘 반영할 때 등) 하에서 risk 개선이 발생하는가?</p></li>
<li><p><strong>RQ3.</strong> Multi-task GP 회귀의 학습 곡선 분석 결과를 활용하여,<br>
similarity-aware prior의 <strong>평균 Bayes error(learning curve)</strong> 에 대한 해석적 표현 또는 근사/상하한을 제시할 수 있는가?</p></li>
<li><p><strong>RQ4.</strong> 제안 prior 구조와 분석 결과는<br>
실제 meta-learning 환경(예: few-shot 회귀/분류 데이터셋)에서 성능 향상 및 불확실성 측정 개선으로 이어지는가?</p></li>
</ul>
<hr>
</section>
</section>
<section id="연구-내용-및-방법" class="level2">
<h2 class="anchored" data-anchor-id="연구-내용-및-방법">5. 연구 내용 및 방법</h2>
<section id="기본-모형-설정" class="level3">
<h3 class="anchored" data-anchor-id="기본-모형-설정">5.1 기본 모형 설정</h3>
<p>본 연구는 다음과 같은 <strong>선형–가우시안 계층 베이지안 meta-learning 모형</strong>을 기본으로 한다.</p>
<ul>
<li>Task <span class="math inline">\(t\)</span>의 회귀 모형: <span class="math display">\[
y_{ti} = x_{ti}^\top \beta_t + \epsilon_{ti}, \quad
\epsilon_{ti} \sim \mathcal{N}(0, \sigma^2),
\]</span> 여기서 <span class="math inline">\(x_{ti} \in \mathbb{R}^d\)</span>, <span class="math inline">\(\beta_t \in \mathbb{R}^d\)</span>.</li>
<li>각 task의 파라미터 벡터를 쌓아 <span class="math display">\[
\beta = (\beta_1^\top, \dots, \beta_T^\top)^\top.
\]</span></li>
</ul>
</section>
<section id="제안-prior-구조-task-similarity-기반-공분산" class="level3">
<h3 class="anchored" data-anchor-id="제안-prior-구조-task-similarity-기반-공분산">5.2 제안 prior 구조: task similarity 기반 공분산</h3>
<section id="독립-prior-baseline" class="level4">
<h4 class="anchored" data-anchor-id="독립-prior-baseline">(1) 독립 prior (baseline)</h4>
<p>기존 계층 모형에서 자주 사용하는 baseline prior는 다음과 같다.</p>
<p><span class="math display">\[
\beta_t \sim \mathcal{N}(0, \tau^2 I_d), \quad t = 1,\dots,T,
\]</span></p>
<p>또는 전체 벡터에 대해</p>
<p><span class="math display">\[
\beta \sim \mathcal{N}(0, I_T \otimes \tau^2 I_d).
\]</span></p>
<p>이는 task 간 독립성을 가정하며, task 간 유사도 구조를 반영하지 않는다.</p>
</section>
<section id="task-similarity-기반-prior" class="level4">
<h4 class="anchored" data-anchor-id="task-similarity-기반-prior">(2) Task similarity 기반 prior</h4>
<p>본 연구에서는 task feature <span class="math inline">\(\phi(t) \in \mathbb{R}^q\)</span> 또는 task 간 거리/그래프 정보를 이용하여<br>
다음과 같은 <strong>task covariance 행렬</strong>을 정의한다.</p>
<ul>
<li>커널 기반 구조: <span class="math display">\[
\Sigma_{\text{task}}(s,t) = k(\phi(s), \phi(t)),
\]</span> 여기서 <span class="math inline">\(k\)</span>는 positive definite kernel (예: RBF, Matérn 등)이다.</li>
<li>그래프 라플라시안 기반 구조: <span class="math display">\[
\Sigma_{\text{task}} = (L + \lambda I)^{-1},
\]</span> 여기서 <span class="math inline">\(L\)</span>은 task 그래프의 라플라시안, <span class="math inline">\(\lambda&gt;0\)</span>는 regularization 파라미터이다.</li>
</ul>
<p>이를 이용하여 전체 prior 공분산을</p>
<p><span class="math display">\[
\operatorname{cov}(\beta) = \Sigma_{\text{task}} \otimes \tau^2 I_d
\]</span></p>
<p>로 정의하는 <strong>similarity-aware prior</strong>를 제안한다.</p>
<p>이때 <span class="math inline">\(k\)</span>의 positive definiteness, <span class="math inline">\(L\)</span>의 성질 등을 이용하여<br>
<span class="math inline">\(\Sigma_{\text{task}}\)</span> 및 <span class="math inline">\(\Sigma_{\text{task}} \otimes \tau^2 I_d\)</span> 가 양정치 행렬이 됨을 보이고,<br>
이에 따라 prior가 well-defined multivariate Gaussian이 됨을 정리 형태로 제시한다.</p>
</section>
</section>
<section id="이론적-분석-계획" class="level3">
<h3 class="anchored" data-anchor-id="이론적-분석-계획">5.3 이론적 분석 계획</h3>
<section id="posterior-및-예측-분포-도출" class="level4">
<h4 class="anchored" data-anchor-id="posterior-및-예측-분포-도출">(1) Posterior 및 예측 분포 도출</h4>
<p>선형–가우시안 모형에서 similarity-aware prior를 사용하면,<br>
posterior 및 posterior predictive distribution은 닫힌형으로 표현 가능하다.</p>
<ul>
<li><p>Posterior: <span class="math display">\[
p(\beta \mid D_{1:T}) = \mathcal{N}(\mu_{\beta\mid D}, \Sigma_{\beta\mid D}),
\]</span> 여기서 <span class="math inline">\(\mu_{\beta\mid D}\)</span>, <span class="math inline">\(\Sigma_{\beta\mid D}\)</span>는 prior 공분산과 데이터 행렬 <span class="math inline">\(X_{1:T}\)</span>, 노이즈 분산 <span class="math inline">\(\sigma^2\)</span>에 의해 결정된다.</p></li>
<li><p>새로운 task <span class="math inline">\(t^\*\)</span> 에 대한 예측 분포: <span class="math display">\[
p(y^\* \mid x^\*, D_{1:T}, D_{t^\*}) = \mathcal{N}(m(x^\*), v(x^\*)),
\]</span></p></li>
</ul>
<p>이를 독립 prior와 similarity-aware prior 두 경우에 대해 명시적으로 도출한다.</p>
</section>
<section id="bayes-risk-비교" class="level4">
<h4 class="anchored" data-anchor-id="bayes-risk-비교">(2) Bayes risk 비교</h4>
<p>새로운 task에서의 예측 MSE를 Bayes risk로 정의한다.</p>
<p><span class="math display">\[
R = \mathbb{E}\left[(y^\* - \hat{y}^\*)^2\right],
\]</span></p>
<p>여기서 기대는 데이터 및 prior/likelihood에 대한 joint 분포에 대해 취한다.</p>
<ul>
<li>독립 prior: <span class="math inline">\(R_{\text{ind}}\)</span></li>
<li>similarity-aware prior: <span class="math inline">\(R_{\text{sim}}\)</span></li>
</ul>
<p>를 각각 계산하거나 상·하한을 도출하고,<br>
특히 task covariance 행렬 <span class="math inline">\(\Sigma_{\text{task}}\)</span>와 참 covariance <span class="math inline">\(\Sigma_{\text{true}}\)</span>의 정렬 정도(예: eigen 구조, 코사인 유사도 등)에 따라</p>
<p><span class="math display">\[
R_{\text{sim}} \le R_{\text{ind}}
\]</span></p>
<p>가 성립하는 조건을 정리 형태(정리/레마)로 제시한다.</p>
<p>이 과정에서 multi-task GP learning curve 분석에서 사용된 테크닉 을 참고하여,<br>
평균 Bayes error를 task 수 <span class="math inline">\(T\)</span>, 각 task의 샘플 수 <span class="math inline">\(n_t\)</span>의 함수로 표현하는 근사식을 도출하는 것을 목표로 한다.</p>
</section>
<section id="학습-곡선learning-curve-관점-해석" class="level4">
<h4 class="anchored" data-anchor-id="학습-곡선learning-curve-관점-해석">(3) 학습 곡선(learning curve) 관점 해석</h4>
<p>Ashton &amp; Sollich의 multi-task GP learning curve 결과를 차용하여,<br>
본 연구에서 정의한 선형–가우시안 모형이 multi-task GP의 특수한 경우에 해당함을 보이고,<br>
similarity-aware prior의 학습 곡선을</p>
<p><span class="math display">\[
\epsilon(n) = \mathbb{E}\left[ (f_{t^\*}(x) - \hat{f}_{t^\*}(x))^2 \right]
\]</span></p>
<p>형태로 표현하거나 근사함으로써,</p>
<ul>
<li>task similarity 구조가 클수록,<br>
</li>
<li>다른 task의 데이터가 많을수록,</li>
</ul>
<p>새로운 task의 Bayes error가 더 빠르게 감소한다는 결과를 이론적으로 설명한다.</p>
</section>
</section>
<section id="시뮬레이션-및-실증-연구-계획" class="level3">
<h3 class="anchored" data-anchor-id="시뮬레이션-및-실증-연구-계획">5.4 시뮬레이션 및 실증 연구 계획</h3>
<ol type="1">
<li><strong>시뮬레이션 환경 구성</strong>
<ul>
<li>Task feature 및 참 task covariance <span class="math inline">\(\Sigma_{\text{true}}\)</span> 를 설계하여,
<ul>
<li><ol type="i">
<li>similarity-aware prior가 참 구조와 잘 맞는 경우,</li>
</ol></li>
<li><ol start="2" type="i">
<li>구조가 mismatch된 경우,</li>
</ol></li>
<li><ol start="3" type="i">
<li>실제로 task들이 독립인 경우, 를 비교.</li>
</ol></li>
</ul></li>
<li>각 설정에서 <span class="math inline">\(T\)</span>, <span class="math inline">\(n_t\)</span>를 변화시키며 독립 prior vs similarity-aware prior의<br>
Bayes risk 및 학습 곡선을 비교.</li>
</ul></li>
<li><strong>실제 데이터 기반 meta-learning 실험</strong>
<ul>
<li>공개된 few-shot 회귀/분류 데이터셋(예: UCI 회귀 데이터셋을 여러 task로 나눈 환경 등)에 대해,</li>
<li>task feature(예: 입력 분포 통계량, domain index 등)를 구성하고<br>
제안 prior 구조를 적용.</li>
<li>예측 정확도, 불확실성 calibration, 샘플 효율성 등의 지표 비교를 통해<br>
이론 결과와의 일관성을 확인.</li>
</ul></li>
</ol>
<hr>
</section>
</section>
<section id="기대-효과-및-학문적-기여" class="level2">
<h2 class="anchored" data-anchor-id="기대-효과-및-학문적-기여">6. 기대 효과 및 학문적 기여</h2>
<ol type="1">
<li><strong>이론적 기여</strong>
<ul>
<li>Task 유사도를 반영한 계층 베이지안 meta-learning prior의 <strong>일반적 구성 틀</strong>을 제시하고,<br>
그 유효성(positive definiteness)과 Bayes risk 측면의 이점을 <strong>정리 형태로 제시</strong>한다.</li>
<li>선형–가우시안 계층 모형에서 similarity-aware prior와 독립 prior의 <strong>risk/learning curve 비교 분석</strong>을 통해,<br>
기존 GP/meta-learning 문헌의 공백을 메운다.</li>
</ul></li>
<li><strong>범용성 있는 방법론 제안</strong>
<ul>
<li>제안 prior 구조는 task feature, 그래프, 클러스터 등 다양한 유사도 정보를 커널/공분산 형태로 통합할 수 있어,<br>
회귀, 분류, GP, BNN 등 다양한 meta-learning 환경에 적용 가능하다.</li>
</ul></li>
<li><strong>Meta-learning 이론과 실용 알고리즘 간의 연결 강화</strong>
<ul>
<li>Multi-task GP와 PAC-Bayesian meta-learning의 이론적 결과를<br>
구체적인 prior 설계 문제와 연결함으로써,<br>
meta-learning 알고리즘 설계에 대한 통계적·이론적 가이드를 제공한다.</li>
</ul></li>
</ol>
<hr>
</section>
<section id="연구-일정-예시-석사-3학기-기준" class="level2">
<h2 class="anchored" data-anchor-id="연구-일정-예시-석사-3학기-기준">7. 연구 일정 (예시: 석사 3학기 기준)</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th>기간</th>
<th>내용</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1학기 전반 (3–4월)</td>
<td>Meta-learning 및 Bayesian/meta-learning, GP, multi-task GP 문헌 조사</td>
</tr>
<tr class="even">
<td>1학기 후반 (5–7월)</td>
<td>모형 설정 구체화, prior 구조 정의, 기본 정리(유효성) 도출</td>
</tr>
<tr class="odd">
<td>여름 방학 (7–8월)</td>
<td>Bayes risk/learning curve 이론적 분석, 초벌 증명 정리</td>
</tr>
<tr class="even">
<td>2학기 전반 (9–10월)</td>
<td>시뮬레이션 코드 구현, synthetic 실험 및 결과 분석</td>
</tr>
<tr class="odd">
<td>2학기 후반 (11–1월)</td>
<td>실증 데이터 실험, 결과 해석 및 이론과의 연결</td>
</tr>
<tr class="even">
<td>3학기 전반 (3–4월)</td>
<td>논문 초고(1–4장) 작성, 정리/보완</td>
</tr>
<tr class="odd">
<td>3학기 후반 (5–7월)</td>
<td>논문 최종 수정, 심사 준비 및 발표</td>
</tr>
</tbody>
</table>
<p>(실제 일정은 지도교수와의 논의를 거쳐 조정 예정)</p>
<hr>
</section>
<section id="참고-문헌-예시" class="level2">
<h2 class="anchored" data-anchor-id="참고-문헌-예시">8. 참고 문헌 (예시)</h2>
<ul>
<li>Hospedales, T., Antoniou, A., Micaelli, P., &amp; Storkey, A. (2021). <em>Meta-Learning in Neural Networks: A Survey</em>.<br>
</li>
<li>Grant, E., Finn, C., Levine, S., Darrell, T., &amp; Griffiths, T. (2018). <em>Recasting Gradient-Based Meta-Learning as Hierarchical Bayes</em>. ICLR.<br>
</li>
<li>Zou, Y., &amp; Lu, X. (2020). <em>Gradient-EM Bayesian Meta-Learning</em>. NeurIPS.<br>
</li>
<li>Nguyen, Q. P., Low, B. K. H., &amp; Jaillet, P. (2021). <em>Learning to Learn with Gaussian Processes</em>. UAI.<br>
</li>
<li>Ashton, S. R. F., &amp; Sollich, P. (2012). <em>Learning Curves for Multi-task Gaussian Process Regression</em>. NeurIPS.<br>
</li>
<li>Rothfuss, J., Josifoski, M., Fortuin, V., &amp; Krause, A. (2021). <em>Scalable PAC-Bayesian Meta-Learning via the PAC-Optimal Hyper-Posterior</em>.<br>
</li>
<li>Chai, K. M. A. (2010). <em>Multi-task Learning with Gaussian Processes</em>.</li>
</ul>
<p>(최종 참고 문헌 목록은 실제 논문 작성 시 추가·수정 예정)</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>